ca65 V2.13.2 - (C) Copyright 1998-2005 Ullrich von Bassewitz
Main file   : apple2pi40col.s
Current file: apple2pi40col.s

000000r 1               ;; Apple Pie
000000r 1               ;;
000000r 1               ;; Egan Ford (egan@sense.net) with a lot of optimizations and pointers from
000000r 1               ;; Anton Treuenfels (atreuenfels@earthlink.net)
000000r 1               ;;
000000r 1               ;; Sept, 8 2012
000000r 1               ;;
000000r 1               ;; Apple Pie (Pi and e) will compute up to 10,000 decimal digits of Pi or e.
000000r 1               ;; All Apple Pie computation is base 256 and then converted to base 10 for
000000r 1               ;; display (technically base 100, but they both display the same).  Arrays
000000r 1               ;; of bytes are used to represent multiprecision numbers.  In the comments
000000r 1               ;; below "array" refers to a big endian multiprecision number.
000000r 1               ;;
000000r 1               ;; Aug, 8 2012
000000r 1               ;;
000000r 1               ;; Increased range to 22950
000000r 1               ;;
000000r 1               
000000r 1               
000000r 1               ;; replace Clobbered: with Registers:
000000r 1               
000000r 1               
000000r 1               ;; Apple II variables/vectors
000000r 1               
000000r 1               getln1	=	$FD6F		; get line of input and store in $200
000000r 1               cout	=	$FDED		; character out sub
000000r 1               prbyte	=	$FDDA		; print a hex byte
000000r 1               crout	=	$FD8E		; CR out sub
000000r 1               rdkey	=	$FD0C		; read key
000000r 1               warm	=	$FF69		; back to monitor
000000r 1               linebuf	=	$200		; input line buffer
000000r 1               promptc	=	$33		; location of getln1 prompt char
000000r 1               
000000r 1               
000000r 1               ;; my variables/vectors
000000r 1               
000000r 1               ptr	=	$0		; $0-$1 16 bit generic pointer
000000r 1               ptr_mp	=	$2		; $2-$3 16 bit generic pointer
000000r 1               a32	=	$4		; $4-$7 32 bit number
000000r 1               carry_mp=	$4		; $4-$4  8 bit multiprecision carry
000000r 1               				;          32/16 div
000000r 1               dividend=	$4		; $4-$7 32 bit
000000r 1               remainder=	$4		; $4-$5 16 bit
000000r 1               quotient=	$6		; $6-$7 16 bit
000000r 1               divisor	=	$8		; $8-$9 16 bit
000000r 1               				;          backup regs
000000r 1               yreg	=	$A		; $A-$A  8 bit
000000r 1               xreg	=	$B		; $B-$B  8 bit
000000r 1               heapptr	=	$C		; $C-$D 16 bit start of free memory
000000r 1               
000000r 1               org	=	$800		; start here
000000r 1               heapend	=	$BFFF		; end of usable memory
000000r 1               max	=	22950		; max number of digits (FYI, 9860 = 4K)
000000r 1               				; 22950 is max because n = n + 2 in atan will get > 32767
000000r 1               				; and div16 bug when divisor 16th bit high.  Need to fix.
000000r 1               min	=	100		; min number of digits
000000r 1               
000000r 1               
000000r 1               
000000r 1               ;; start of global macros
000000r 1               
000000r 1               .include	"pimacros.m"
000000r 2               .macro	cnton num
000000r 2               	sta	$E100+num
000000r 2               .endmacro
000000r 2               
000000r 2               .macro	cntoff num
000000r 2               	sta	$E200+num
000000r 2               .endmacro
000000r 2               
000000r 2               .macro	chkpt num
000000r 2               	sta	$E300+num
000000r 2               .endmacro
000000r 2               
000000r 2               ; Description:	Load A/Y registers with a 16-bit value,
000000r 2               ;               low byte in A, high byte in Y
000000r 2               ; Input:        value (16-bit) immediate, absolute and zero-page addressing
000000r 2               
000000r 2               .macro	lday	value
000000r 2               	.if (.match (.left (1, {value}), #))
000000r 2               		lda	#<(.right (.tcount ({value})-1, {value}))
000000r 2               		ldy	#>(.right (.tcount ({value})-1, {value}))
000000r 2               	.else
000000r 2               		lda	value
000000r 2               		ldy	value+1
000000r 2               	.endif
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:  Store 16-bit value in A/Y registers to memory,
000000r 2               ;               low byte in A, high byte in Y
000000r 2               ; Input:        value (16-bit), absolute and zero-page addressing
000000r 2               
000000r 2               .macro	stay	location
000000r 2               	sta	location
000000r 2               	sty	location+1
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Allocate an array of size "sizeof" at "ptr"
000000r 2               ; Input:	ptr (16-bit), sizeof (16-bit)
000000r 2               ;		ptr = pointer to start of memory (if successful)
000000r 2               ;		sizeof = length of requested memory, length can be
000000r 2               ;		immediate (e.g. #1000) or absolute/zp (label)
000000r 2               ; Calls:	malloc, if malloc fails then calls malloc_error and dies
000000r 2               ;		program.
000000r 2               
000000r 2               .macro	alloc	ptr, sizeof
000000r 2               	lday	sizeof
000000r 2               	jsr	malloc		; call malloc
000000r 2               	bcc	:+		; if not failure (bcc) set ptr lo/hi
000000r 2               	jmp	malloc_error	; on failure jmp to malloc_error and die
000000r 2               :	stay	ptr
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Set initial value left of decimal of "ptr_a" array to
000000r 2               ;		"value", i.e. (ptr_a),0 = value
000000r 2               ; Input:	ptr_a (16-bit), value (8-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		value = integer to be set left of decimal point
000000r 2               ; Calls:	set_mp
000000r 2               
000000r 2               .macro	mset	ptr_a, value	; a = value
000000r 2               cnton 19
000000r 2               	lday	ptr_a
000000r 2               	ldx	value
000000r 2               	jsr	set_mp		; set it
000000r 2               cntoff 19
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Transfer array (ptr_b)[0,sizeof(ptr_b)] to ptr_a (a = b)
000000r 2               ; Input:	ptr_a (16-bit), ptr_b (16-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		ptr_b = pointer to start of allocated array
000000r 2               ; Calls:	copy_mp
000000r 2               
000000r 2               .macro	mcopy	ptr_a, ptr_b	; a = b
000000r 2               cnton 20
000000r 2               	lday	ptr_a
000000r 2               	stay	ptr_mp
000000r 2               	lday	ptr_b
000000r 2               	jsr	copy_mp		; copy it
000000r 2               cntoff 20
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Left shift array ptr_a
000000r 2               ; Input:	ptr_a (16-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ; Calls:	asl_mp
000000r 2               
000000r 2               .macro	masl	ptr_a		; a = a * 2
000000r 2               cnton 21
000000r 2               	lday	ptr_a
000000r 2               	jsr	asl_mp		; left shift it
000000r 2               cntoff 21
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Add array ptr_b to array ptr_a (a = a + b)
000000r 2               ; Input:	ptr_a (16-bit), ptr_b (16-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		ptr_b = pointer to start of allocated array
000000r 2               ; Calls:	add_mp
000000r 2               
000000r 2               .macro	madd	ptr_a, ptr_b	; a = a + b
000000r 2               cnton 22
000000r 2               	lday	ptr_b
000000r 2               	stay	ptr_mp
000000r 2               	lday	ptr_a
000000r 2               	jsr	add_mp		; add it
000000r 2               cntoff 22
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Subtract array ptr_b from array ptr_a (a = a - b)
000000r 2               ; Input:	ptr_a (16-bit), ptr_b (16-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		ptr_b = pointer to start of allocated array
000000r 2               ; Calls:	sub_mp
000000r 2               
000000r 2               .macro	msub	ptr_a, ptr_b	; a = a - b
000000r 2               cnton 23
000000r 2               	lday	ptr_b
000000r 2               	stay	ptr_mp
000000r 2               	lday	ptr_a
000000r 2               	jsr	sub_mp		; sub it
000000r 2               cntoff 23
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Divide ptr_a by an 8-bit quantity (a = a / divisor)
000000r 2               ; Input:	ptr_a (16-bit), divisor (8-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		divisor = 8-bit immediate or absolute/zp integer
000000r 2               ; Calls:	div_mp
000000r 2               ; Return:	If ptr_a = 0 (array of zeros), then carry is set,
000000r 2               ;		otherwise carry is clear.
000000r 2               
000000r 2               .macro	mdiv	ptr_a, divisor	; a = a / divisor (8-bit)
000000r 2               cnton 24
000000r 2               	lday	ptr_a
000000r 2               	ldx	divisor
000000r 2               	jsr	div_mp		; div it
000000r 2               cntoff 24
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Divide ptr_a by a 16-bit quantity (a = a / value)
000000r 2               ; Input:	ptr_a (16-bit), value (8-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		value = 16-bit immediate or absolute/zp integer
000000r 2               ; Calls:	div16_mp
000000r 2               ; Return:	If ptr_a = 0 (array of zeros), then carry is set,
000000r 2               ;		otherwise carry is clear
000000r 2               
000000r 2               .macro	mdiv16	ptr_a, value	; a = a / value (16-bit)
000000r 2               cnton 25
000000r 2               	lday	value
000000r 2               	sty	divisor+0	; big-endian
000000r 2               	sta	divisor+1
000000r 2               	lday	ptr_a
000000r 2               	jsr	div16_mp	; div it
000000r 2               cntoff 25
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Compute arctan(1/value) and store at ptr_a.
000000r 2               ; Input:	ptr_a (16-bit), value (8-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		value = 8-bit immediate or absolute/zp integer
000000r 2               ; Calls:	atan_mp
000000r 2               
000000r 2               .macro	matan	ptr_a, value	; a = atan(1/value)
000000r 2               cnton 26
000000r 2               	lday	ptr_a
000000r 2               	ldx	value
000000r 2               	jsr	atan_mp		; atan it
000000r 2               cntoff 26
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Convert and print/display a base 256 number (ptr_a) as
000000r 2               ;		base 10.
000000r 2               ; Input:	ptr_a (16-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ; Calls:	print_mp
000000r 2               
000000r 2               .macro	mprint	ptr_a		; print a (base 10)
000000r 2               cnton 27
000000r 2               	lday	ptr_a
000000r 2               	jsr	print_mp	; print it
000000r 2               cntoff 27
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Print a string (arg) with an optional trailing character
000000r 2               ;		(usually a carriage return (CR = $0D)).
000000r 2               ; Input:	immediate with extra:		"string",$0D
000000r 2               ;		immediate w/o extra:		"string"
000000r 2               ;		absolue/zp label with extra:	label,$0D
000000r 2               ;		absolue/zp label w/o extra:	label
000000r 2               ; Calls:	print, crout
000000r 2               
000000r 2               .macro	sprint	arg, cr
000000r 2               	.local	str
000000r 2               	.local	skip
000000r 2               	.if .match ({arg},"")
000000r 2               		lday	#str
000000r 2               		jsr	print
000000r 2               		beq	skip
000000r 2               	str:	.byte	arg
000000r 2               	.ifnblank	cr
000000r 2               		.byte	cr
000000r 2               	.endif
000000r 2               		.byte	$0
000000r 2               	skip:
000000r 2               	.else
000000r 2               		lday	#arg
000000r 2               		jsr	print
000000r 2               		.ifnblank	cr
000000r 2               		jsr	crout
000000r 2               		.endif
000000r 2               	.endif
000000r 2               .endmacro
000000r 2               
000000r 1               
000000r 1               
000000r 1               ; Description:	Get time from clock card (if present) and store in "ptr"
000000r 1               ; Input:	16-bit ptr to array of 4 bytes (s,m,h,100th sec)
000000r 1               ; Calls:	gettime
000000r 1               
000000r 1               .macro	time	ptr
000000r 1               	ldx	gotclock
000000r 1               	beq	:+
000000r 1               	lday	#ptr
000000r 1               	jsr	gettime
000000r 1               :
000000r 1               .endmacro
000000r 1               
000000r 1               ;; end of macros
000000r 1               
000000r 1               
000000r 1               ;; use for DOS header, NOTE: will mess with .align statements
000000r 1               	;.byte  <begin,>begin,<(end-begin),>(end-begin)
000000r 1               
000000r 1               
000000r 1               ;; start of real code
000000r 1               	.org	org
000800  1               begin:
000800  1               	;; check for 80 col code here
000800  1               	;; clear/home screen code
000800  1               	; lazy, going to hard code for now, in the future check for //e with
000800  1               	;   80 col card, or //c, IIgs, or Videx, else die
000800  1               	;lda	#$00		; load up $36/$37
000800  1               	;sta	$36		; with $C300
000800  1               	;lda	#$C3		; i.e. pr#3
000800  1               	;sta	$37		; or C300G
000800  1               
000800  1  A2 23        	ldx	#35		; print 35 spaces to center title
000802  1  A9 A0        :	lda	#' '+$80
000804  1  20 ED FD     	jsr	cout
000807  1  CA           	dex
000808  1  D0 F8        	bne	:-
00080A  1  A9 13 A0 08  	sprint	"Apple Pi/e",$0D
00080E  1  20 CC 19 F0  
000812  1  0C 41 70 70  
000816  1  6C 65 20 50  
00081A  1  69 2F 65 0D  
00081E  1  00           
00081F  1  20 8E FD     	jsr	crout		; print CR
000822  1  20 8E FD     	jsr	crout		; print CR
000825  1               
000825  1               	; check for no slot clock
000825  1  20 25 1A     	jsr	detect_noslotclock
000828  1  90 2A        	bcc	:+		; if carry clear, no 'no slot clock'
00082A  1  A9 01        	lda	#1
00082C  1  8D C6 0B     	sta	gotclock	; set clock type to 1
00082F  1  A9 38 A0 08  	sprint	"'No Slot Clock' detected",$0D
000833  1  20 CC 19 F0  
000837  1  1A 27 4E 6F  
00083B  1  20 53 6C 6F  
00083F  1  74 20 43 6C  
000843  1  6F 63 6B 27  
000847  1  20 64 65 74  
00084B  1  65 63 74 65  
00084F  1  64 0D 00     
000852  1  F0 40        	beq	setup		; branch to setup
000854  1               :
000854  1               	; check for thunderclock card
000854  1  20 ED 19     	jsr	detect_thunderclock
000857  1  E0 00        	cpx	#0		; slot returned in x
000859  1  F0 39        	beq	:+		; no thunder clock if x = 0
00085B  1  A9 02        	lda	#2
00085D  1  8D C6 0B     	sta	gotclock	; set clock type to 2
000860  1  8E C7 0B     	stx	clockslot	; save the card slot number
000863  1  A9 6C A0 08  	sprint	"Thunderclock detected in slot "
000867  1  20 CC 19 F0  
00086B  1  1F 54 68 75  
00086F  1  6E 64 65 72  
000873  1  63 6C 6F 63  
000877  1  6B 20 64 65  
00087B  1  74 65 63 74  
00087F  1  65 64 20 69  
000883  1  6E 20 73 6C  
000887  1  6F 74 20 00  
00088B  1  8A           	txa			; transfer slot number to A
00088C  1  09 B0        	ora	#$B0		; convert to ASCII
00088E  1  20 ED FD     	jsr	cout		; print it
000891  1  20 8E FD     	jsr	crout		; CR
000894  1               :
000894  1               
000894  1               setup:				; initial setup
000894  1  20 8E FD     	jsr	crout		; CR
000897  1  A9 BA        	lda	#':'+$80	; update prompt char just in case user hits <-
000899  1  85 33        	sta	promptc		;   and store it
00089B  1               
00089B  1               start:				; prompt for pi or e
00089B  1  A9 50        	lda	#'P'
00089D  1  8D C3 0B     	sta	constant
0008A0  1  A9 69        	lda	#'i'
0008A2  1  8D C4 0B     	sta	constant+1
0008A5  1  A9 FF        	lda	#-1
0008A7  1  8D C2 0B     	sta	pie
0008AA  1  A9 B3 A0 08  	sprint	"Compute [P]i or [e]? "
0008AE  1  20 CC 19 F0  
0008B2  1  16 43 6F 6D  
0008B6  1  70 75 74 65  
0008BA  1  20 5B 50 5D  
0008BE  1  69 20 6F 72  
0008C2  1  20 5B 65 5D  
0008C6  1  3F 20 00     
0008C9  1  20 0C FD     :	jsr	rdkey		; read one keystroke
0008CC  1  09 A0        	ora	#%10100000	; convert to lower case + $80
0008CE  1  C9 F0        	cmp	#'p'+$80	; got P?
0008D0  1  F0 13        	beq	:++		;   branch two :
0008D2  1  C9 E5        	cmp	#'e'+$80	; got E?
0008D4  1  F0 02        	beq	:+		;   branch one :
0008D6  1  D0 F1        	bne	:-		; none of the above, go back and try again
0008D8  1  EE C2 0B     :	inc	pie		; e,   pie = 1
0008DB  1  A9 65        	lda	#'e'		; wipe out "Pi" and replace with "e",null
0008DD  1  8D C3 0B     	sta	constant
0008E0  1  A9 00        	lda	#0
0008E2  1  8D C4 0B     	sta	constant+1
0008E5  1  EE C2 0B     :	inc	pie		; pi,  pie = 0
0008E8  1  A9 C3 A0 0B  	sprint	constant	; display selection
0008EC  1  20 CC 19     
0008EF  1  20 8E FD     	jsr	crout		; print CR
0008F2  1  20 8E FD     	jsr	crout		; print CR
0008F5  1               
0008F5  1               printer:			; prompt for printer code
0008F5  1  A9 FE A0 08  	sprint	"Print to slot (1-7), (0 or RETURN for no printout)? "
0008F9  1  20 CC 19 F0  
0008FD  1  35 50 72 69  
000901  1  6E 74 20 74  
000905  1  6F 20 73 6C  
000909  1  6F 74 20 28  
00090D  1  31 2D 37 29  
000911  1  2C 20 28 30  
000915  1  20 6F 72 20  
000919  1  52 45 54 55  
00091D  1  52 4E 20 66  
000921  1  6F 72 20 6E  
000925  1  6F 20 70 72  
000929  1  69 6E 74 6F  
00092D  1  75 74 29 3F  
000931  1  20 00        
000933  1  20 0C FD     :	jsr	rdkey		; read one keystroke
000936  1  09 80        	ora	#$80		; set hi bit (it's an apple thing)
000938  1  C9 8D        	cmp	#$8D		; check for return
00093A  1  F0 0A        	beq	:+		; jump to fake a zero on display
00093C  1  C9 B8        	cmp	#$B8		; >= ASCII 8?
00093E  1  B0 F3        	bcs	:-		; yep, try again
000940  1  C9 B0        	cmp	#$B0		; < ASCII 0?
000942  1  B0 04        	bcs	:++		; nope, move on
000944  1  90 ED        	bcc	:-		; yep, try again
000946  1  A9 B0        :	lda	#$B0		; fake a zero
000948  1  20 ED FD     :	jsr	cout		; display slot
00094B  1  29 07        	and	#%00000111	; mask off last 3 bits
00094D  1  8D C1 0B     	sta	prslot		; save it for later
000950  1  20 8E FD     	jsr	crout		; print CR
000953  1               
000953  1               	;; prompt for 6502 or 6809 or both
000953  1               	; eventually I'll get the 6809 version of this for Stellation 6809
000953  1               	; co-processor cards
000953  1               
000953  1               inputrange:
000953  1  20 8E FD     	jsr	crout		; print CR
000956  1  A9 5F A0 09  	sprint	"Number of "
00095A  1  20 CC 19 F0  
00095E  1  0B 4E 75 6D  
000962  1  62 65 72 20  
000966  1  6F 66 20 00  
00096A  1  A9 C3 A0 0B  	sprint	constant	; Pi or e
00096E  1  20 CC 19     
000971  1  A9 7A A0 09  	sprint	" digits (100-22950): "
000975  1  20 CC 19 F0  
000979  1  16 20 64 69  
00097D  1  67 69 74 73  
000981  1  20 28 31 30  
000985  1  30 2D 32 32  
000989  1  39 35 30 29  
00098D  1  3A 20 00     
000990  1  20 6F FD     	jsr	getln1		; get line of input, length in x
000993  1  E0 06        	cpx	#6		; if x >= 6 (should be int(log10(max)) + 1)
000995  1  B0 0A        	bcs	rangeerror	;   error out and branch to rangeerror
000997  1  A9 00        	lda	#0		; put a null at the end of the string
000999  1  9D 00 02     	sta	linebuf,x	;   for asciitohex (plus display/printing)
00099C  1  20 3A 19     	jsr	asciitohex	; returns 16-bit hex lo in a and hi in y
00099F  1  90 32        	bcc	noinputerror	;   if no carry set, then no asciitohex error
0009A1  1               rangeerror:
0009A1  1  20 8E FD     	jsr	crout		; print CR
0009A4  1  A9 AD A0 09  	sprint	"Digits must be in range 100-22950.",$0D
0009A8  1  20 CC 19 F0  
0009AC  1  24 44 69 67  
0009B0  1  69 74 73 20  
0009B4  1  6D 75 73 74  
0009B8  1  20 62 65 20  
0009BC  1  69 6E 20 72  
0009C0  1  61 6E 67 65  
0009C4  1  20 31 30 30  
0009C8  1  2D 32 32 39  
0009CC  1  35 30 2E 0D  
0009D0  1  00           
0009D1  1  F0 80        	beq	inputrange	; free zero from sprint
0009D3  1               noinputerror:			; check for range error
0009D3  1               				; last operation from asciitohex was ldy (hi)
0009D3  1  D0 04        	bne	highcheck	; check for > 22950
0009D5  1  C9 64        	cmp	#min		; if < 100
0009D7  1  90 C8        	bcc	rangeerror
0009D9  1               highcheck:
0009D9  1  C0 59        	cpy	#>max
0009DB  1  90 06        	bcc	rangeok		; < 22950
0009DD  1  D0 C2        	bne	rangeerror	; > 22950
0009DF  1  C9 A7        	cmp	#(<max)+1	; got hi bits, need to check for lo bits in a
0009E1  1  B0 BE        	bcs	rangeerror	; >= lo bits
0009E3  1               rangeok:
0009E3  1  8D D4 0B     	sta	declen		; save declen lo (declen used for print_mp)
0009E6  1  8D D0 0B     	sta	arraylen	; save arraylen lo
0009E9  1  8C D5 0B     	sty	declen+1	; save declen hi
0009EC  1  8C D1 0B     	sty	arraylen+1	; save arraylen hi
0009EF  1               	; need to add one to range for the "3." that is left of
0009EF  1               	; the decimal digits, i.e. 1000 digits is really 1001
0009EF  1  EE D0 0B     	inc	arraylen	; arraylen++ (lo = lo + 1)
0009F2  1  D0 03        	bne	:+		; if rolled to 0 then
0009F4  1  EE D1 0B     	inc	arraylen+1	; inc arraylen hi
0009F7  1               :	; at this point we have a valid number between 100-22950 inclusive
0009F7  1               	;
0009F7  1               	; compute ceil(number decimal digits * 1/log(256) + 1) to compute
0009F7  1               	; the number of base(256) digits to use
0009F7  1               	;
0009F7  1               	;   1st, multiply arraylen by 1/log(256) (0.6A4D)
0009F7  1               	;   2nd, ceil (round up) the result + 1 guard digit
0009F7  1               	;   3rd, add extra guard digits for accuracy
0009F7  1               
0009F7  1               	; 1. arraylen/log(256)
0009F7  1               	;
0009F7  1               log256:	; fixed point 32-bit math product/result
0009F7  1  A9 00        	lda	#0
0009F9  1  85 04        	sta	a32		; right of the decimal (< 0)
0009FB  1  85 05        	sta	a32+1
0009FD  1  85 06        	sta	a32+2		; left of the decimal (> 0)
0009FF  1  85 07        	sta	a32+3
000A01  1  A2 10        	ldx	#16
000A03  1  D0 08        	bne	:++		; skip first shift
000A05  1  06 04        :	asl	a32		; shift ...
000A07  1  26 05        	rol	a32+1
000A09  1  26 06        	rol	a32+2
000A0B  1  26 07        	rol	a32+3
000A0D  1  0E D0 0B     :	asl	arraylen	; get high bit
000A10  1  2E D1 0B     	rol	arraylen+1
000A13  1  90 15        	bcc	:+		; zero bit, next
000A15  1  18           	clc			; ... and add
000A16  1  A9 4D        	lda	#$4D		; 1/log(256)
000A18  1  65 04        	adc	a32
000A1A  1  85 04        	sta	a32
000A1C  1  A9 6A        	lda	#$6A		; 1/log(256)
000A1E  1  65 05        	adc	a32+1
000A20  1  85 05        	sta	a32+1
000A22  1  90 06        	bcc	:+		; no carry, no prob
000A24  1  E6 06        	inc	a32+2		; got carry, inc next MSD
000A26  1  D0 02        	bne	:+		; inc does not set carry, but if rolled to
000A28  1  E6 07        	inc	a32+3		;   zero, then it's a carry, inc MSD
000A2A  1  CA           :	dex			; not zero
000A2B  1  D0 D8        	bne	:---		;   then back to top of loop
000A2D  1               
000A2D  1               	; 2. compute ceil and add a guard digit
000A2D  1               	; x = 0 now (free 0!)
000A2D  1               	;
000A2D  1  A0 02        ceil:	ldy	#2		; assumed ceil + one guard digit
000A2F  1               
000A2F  1  E4 04        	cpx	a32		; right of decimal not 0?  round up (ceil)
000A31  1  D0 05        	bne	guards		;   truncate and keep Y = 2
000A33  1  E4 05        	cpx	a32+1		; right of decimal not 0?  round up (ceil)
000A35  1  D0 01        	bne	guards		;   truncate and keep Y = 2
000A37  1  88           	dey			; remove assumed ceil (prob never happend)
000A38  1               
000A38  1               	; 3. if declen > 1000 ($3E8), then A = A + 2 more guard digits.
000A38  1               	;
000A38  1  AD D4 0B     guards: lda	declen		; 16-bit compare
000A3B  1  C9 E9        	cmp	#<1001		; if # of decimal digits > 1000
000A3D  1  AD D5 0B     	lda	declen+1	;   then add two more guard digits, this will
000A40  1  E9 03        	sbc	#>1001		;   be sufficient for up to 22950 digits
000A42  1  90 02        	bcc	:+		; branch if declen < 1001
000A44  1  C8           	iny			;   otherwise add two more guard digits
000A45  1  C8           	iny			;   then transfer to A
000A46  1  98           :	tya			; A = ceil + guards
000A47  1  18           	clc			; add guard+ceil digits to /log256
000A48  1  65 06        	adc	a32+2		;   and save in arraylen
000A4A  1  8D D0 0B     	sta	arraylen
000A4D  1  A9 00        	lda	#0
000A4F  1  65 07        	adc	a32+3
000A51  1  8D D1 0B     	sta	arraylen+1
000A54  1               
000A54  1               	; almost done
000A54  1               	;
000A54  1               	; make arraylen even to optimize Duff Device branch decisions
000A54  1               	;   this will make the code a bit shorter, but also a bit slower
000A54  1               	;   on the order of 1/1000ths of seconds or less total time 50% of the
000A54  1               	;   time, IOW not going to worry about it.
000A54  1               	;
000A54  1  AD D0 0B     	lda	arraylen	; load LSB arraylen
000A57  1  4A           	lsr			; shift LSBit to carry
000A58  1  90 08        	bcc	:+		; is even, then skip
000A5A  1  EE D0 0B     	inc	arraylen	; is odd, then plus one to make even
000A5D  1  D0 03        	bne	:+		; arraylen rolled to zero?
000A5F  1  EE D1 0B     	inc	arraylen+1	; got zero, inc arraylen+1
000A62  1               :
000A62  1               	; compute arrayend, used by loops that start from end
000A62  1               	;
000A62  1  AD D1 0B     	lda	arraylen+1	; arrayend = arraylen - 1
000A65  1  8D D3 0B     	sta	arrayend+1
000A68  1  AD D0 0B     	lda	arraylen
000A6B  1  8D D2 0B     	sta	arrayend
000A6E  1  D0 03        	bne	:+		; check if arraylen (lo) is zero, if zero,
000A70  1  CE D3 0B     	dec	arrayend+1	;   then it will rollback to $FF, so dec (hi)
000A73  1  CE D2 0B     :	dec	arrayend	; dec (lo)
000A76  1               
000A76  1               	; finally done with entry and setup, time for some Pie!!!
000A76  1               
000A76  1               initheap:			; setup heap pointer
000A76  1  A9 99 A0 1E  	lday	#heap		; This is the start of dynamically allocated
000A7A  1  85 0C 84 0D  	stay	heapptr		; memory.  This needs to be done each time Pi
000A7E  1               				; or e is computed to free up old arrays.
000A7E  1               
000A7E  1               alloc_pointers:			; allocate all arrays (we need 4 for Pi)
000A7E  1  AD D0 0B AC  	alloc	mp_a,arraylen	; allocate mp_a with size arraylen
000A82  1  D1 0B 20 1A  
000A86  1  19 90 03 4C  
000A8A  1  9B 19 8D D6  
000A8E  1  0B 8C D7 0B  
000A92  1  AD D0 0B AC  	alloc	mp_b,arraylen	;   error on failure and die
000A96  1  D1 0B 20 1A  
000A9A  1  19 90 03 4C  
000A9E  1  9B 19 8D D8  
000AA2  1  0B 8C D9 0B  
000AA6  1  AD D0 0B AC  	alloc	mp_x,arraylen
000AAA  1  D1 0B 20 1A  
000AAE  1  19 90 03 4C  
000AB2  1  9B 19 8D DA  
000AB6  1  0B 8C DB 0B  
000ABA  1  AD D0 0B AC  	alloc	mp_y,arraylen
000ABE  1  D1 0B 20 1A  
000AC2  1  19 90 03 4C  
000AC6  1  9B 19 8D DC  
000ACA  1  0B 8C DD 0B  
000ACE  1               
000ACE  1               				; if printout, enable printer
000ACE  1  AD C1 0B     	lda	prslot		; load prslot value (0-7)
000AD1  1  F0 08        	beq	:+		; if zero no print
000AD3  1  09 C0        	ora	#$C0		; setup redir by storing
000AD5  1  85 37        	sta	$37		; $C<slot>00 in $36/$37
000AD7  1  A9 00        	lda	#$00
000AD9  1  85 36        	sta	$36
000ADB  1               :
000ADB  1               header:				; print header
000ADB  1  20 8E FD     	jsr	crout		; print CR
000ADE  1  A9 E7 A0 0A  	sprint	"Computing "
000AE2  1  20 CC 19 F0  
000AE6  1  0B 43 6F 6D  
000AEA  1  70 75 74 69  
000AEE  1  6E 67 20 00  
000AF2  1  A9 C3 A0 0B  	sprint	constant
000AF6  1  20 CC 19     
000AF9  1  A9 02 A0 0B  	sprint	" to "
000AFD  1  20 CC 19 F0  
000B01  1  05 20 74 6F  
000B05  1  20 00        
000B07  1  A9 00 A0 02  	sprint	linebuf
000B0B  1  20 CC 19     
000B0E  1  A9 17 A0 0B  	sprint	" digits..."
000B12  1  20 CC 19 F0  
000B16  1  0B 20 64 69  
000B1A  1  67 69 74 73  
000B1E  1  2E 2E 2E 00  
000B22  1               
000B22  1  AE C6 0B F0  	time	starttime	; if clock detected, store start time
000B26  1  07 A9 C8 A0  
000B2A  1  0B 20 30 1A  
000B2E  1  8D 01 E1     cnton	1
000B31  1  AD C2 0B     	lda	pie		; check pie flag for pi = 0. e = 1
000B34  1  F0 05        	beq	:+		; if zero branch to jsr pi
000B36  1  20 56 0C     	jsr	e		;   else jsr e
000B39  1  B0 03        	bcs	:++		; carry set after e run
000B3B  1  20 DE 0B     :	jsr	pi
000B3E  1  20 8E FD     :	jsr	crout
000B41  1  20 8E FD     	jsr	crout
000B44  1  8D 1B E1 AD  	mprint	mp_a		; print it (note mp_a hosed)
000B48  1  D6 0B AC D7  
000B4C  1  0B 20 D0 17  
000B50  1  8D 1B E2     
000B53  1  20 8E FD     	jsr	crout		; print CR
000B56  1  8D 01 E2     cntoff	1
000B59  1  AE C6 0B F0  	time	endtime		; if clock detected, start end time
000B5D  1  07 A9 CC A0  
000B61  1  0B 20 30 1A  
000B65  1  20 88 1A     	jsr	printtime	;   and print the wallclock time
000B68  1  20 8E FD     	jsr	crout
000B6B  1               				; if printout, disable printer
000B6B  1  AD C1 0B     	lda	prslot		; load prslot value (0-7)
000B6E  1  F0 08        	beq	:+		; if zero no print
000B70  1  A9 00        	lda	#$00		; hard coded load of $C300 in $36/$37
000B72  1  85 36        	sta	$36		;  i.e. pr#3
000B74  1  A9 C3        	lda	#$C3
000B76  1  85 37        	sta	$37
000B78  1               :
000B78  1  A9 81 A0 0B  	sprint	"More Pie? "	; who doesn't want more Pie?
000B7C  1  20 CC 19 F0  
000B80  1  0B 4D 6F 72  
000B84  1  65 20 50 69  
000B88  1  65 3F 20 00  
000B8C  1  20 0C FD     :	jsr	rdkey		; read a single keystroke
000B8F  1  09 A0        	ora	#%10100000	; convert to lower case + $80
000B91  1  C9 EE        	cmp	#'n'+$80	; check for N or
000B93  1  F0 1C        	beq	:++
000B95  1  C9 F9        	cmp	#'y'+$80	; Y
000B97  1  F0 02        	beq	:+
000B99  1  D0 F1        	bne	:-		; if not N/Y retry.
000B9B  1  A9 A4 A0 0B  :	sprint	"Yes"		; print "Yes" if y
000B9F  1  20 CC 19 F0  
000BA3  1  04 59 65 73  
000BA7  1  00           
000BA8  1  20 8E FD     	jsr	crout
000BAB  1  20 8E FD     	jsr	crout
000BAE  1  4C 9B 08     	jmp	start		; start over with all prompts
000BB1  1  A9 BA A0 0B  :	sprint	"No"		; print "No" if n
000BB5  1  20 CC 19 F0  
000BB9  1  03 4E 6F 00  
000BBD  1  20 8E FD     	jsr	crout		; print CR
000BC0  1  60           	rts			;  and exit
000BC1  1               
000BC1  1               
000BC1  1               ;; end of main code, start of non-zp allocations
000BC1  1               
000BC1  1  00           prslot:	.byte	$0		; Printer slot
000BC2  1  00           pie:	.byte	$0		; Pi or e flag, pi = 0, e = 1
000BC3  1               constant:			; Pi or e text
000BC3  1  00 00 00     	.byte	$0, $0, $0
000BC6  1               gotclock:
000BC6  1  00           	.byte	$0		; clock type
000BC7  1               clockslot:
000BC7  1  00           	.byte	$0		; clock slot
000BC8  1               starttime:
000BC8  1  00 00 00 00  	.byte	$0, $0, $0, $0	; start time (s,m,h,1/100 s)
000BCC  1               endtime:
000BCC  1  00 00 00 00  	.byte	$0, $0, $0, $0	; end time (s,m,h,1/100 s)
000BD0  1               arraylen:
000BD0  1  00 00        	.byte	$0, $0		; length of base 256 array
000BD2  1               arrayend:
000BD2  1  00 00        	.byte	$0, $0		; last byte of array
000BD4  1  00 00        declen:	.byte	$0, $0		; decimal length of digits
000BD6  1  00 00        mp_a:	.byte	$0, $0		; mp pointer
000BD8  1  00 00        mp_b:	.byte	$0, $0		; mp pointer
000BDA  1  00 00        mp_x:	.byte	$0, $0		; mp pointer
000BDC  1  00 00        mp_y:	.byte	$0, $0		; mp pointer
000BDE  1               
000BDE  1               
000BDE  1               ;; start of subs
000BDE  1               
000BDE  1               ; Description: Compute pi using the Gregory expansion of Machin's arctan
000BDE  1               ;              formula and save in array (mp_a) (hardcoded--bad).
000BDE  1               ;
000BDE  1               ;   pi = 4 * (4 *      atan(1/5)           -           atan(1/239)          )
000BDE  1               ;
000BDE  1               ;
000BDE  1               ;   __      /   / 1     1      1       \       / 1       1        1        \\
000BDE  1               ;   || = 4 | 4 |  - - ---- + ---- - ... |  -  | --- - ------ + ------ - ... ||
000BDE  1               ;          |   |  5      3      5       |     | 239        3        5       ||
000BDE  1               ;           \   \     3x5    5x5       /       \      3x239    5x239       //
000BDE  1               ;
000BDE  1               ;
000BDE  1               ; Input:       None
000BDE  1               ;
000BDE  1               ; Output:      (mp_a) = pi = 4 * (4 * atan(1/5) - atan(1/239))
000BDE  1               ;
000BDE  1               ; Clobbered:   A, X, Y
000BDE  1               ;
000BDE  1               ; Calls:       matan/atan_mp, masl/asl_mp, msub/sub_mp
000BDE  1               
000BDE  1  8D 1A E1 AD  pi:	matan	mp_a,#5		; a = atan(1/5)
000BE2  1  D6 0B AC D7  
000BE6  1  0B A2 05 20  
000BEA  1  F1 0C 8D 1A  
000BEE  1  E2           
000BEF  1  8D 15 E1 AD  	masl	mp_a		; a = a * 4
000BF3  1  D6 0B AC D7  
000BF7  1  0B 20 A4 0E  
000BFB  1  8D 15 E2     
000BFE  1  8D 15 E1 AD  	masl	mp_a
000C02  1  D6 0B AC D7  
000C06  1  0B 20 A4 0E  
000C0A  1  8D 15 E2     
000C0D  1  8D 1A E1 AD  	matan	mp_b,#239	; b = atan(1/239)
000C11  1  D8 0B AC D9  
000C15  1  0B A2 EF 20  
000C19  1  F1 0C 8D 1A  
000C1D  1  E2           
000C1E  1  8D 17 E1 AD  	msub	mp_a,mp_b	; a = a - b
000C22  1  D8 0B AC D9  
000C26  1  0B 85 02 84  
000C2A  1  03 AD D6 0B  
000C2E  1  AC D7 0B 20  
000C32  1  5D 0E 8D 17  
000C36  1  E2           
000C37  1  8D 15 E1 AD  	masl	mp_a		; a = a * 4
000C3B  1  D6 0B AC D7  
000C3F  1  0B 20 A4 0E  
000C43  1  8D 15 E2     
000C46  1  8D 15 E1 AD  	masl	mp_a
000C4A  1  D6 0B AC D7  
000C4E  1  0B 20 A4 0E  
000C52  1  8D 15 E2     
000C55  1  60           	rts
000C56  1               
000C56  1               
000C56  1               ; Description: Compute e using the infinite series:
000C56  1               ;
000C56  1               ;               oo
000C56  1               ;              =====
000C56  1               ;              \      1
000C56  1               ;      e   =    >    --  = 1 + 1/1! + 1/2! + 1/3! + 1/4! + ...
000C56  1               ;              /     k!
000C56  1               ;              =====
000C56  1               ;              k = 0
000C56  1               ;
000C56  1               ;              and save in array (mp_a) (hardcoded--bad).
000C56  1               ;
000C56  1               ; Input:       None
000C56  1               ;
000C56  1               ; Output:      (mp_a) = e = 1 + 1/1! + 1/2! + 1/3! + 1/4! + ...
000C56  1               ;
000C56  1               ; Clobbered:   A, X, Y
000C56  1               ;
000C56  1               ; Calls:       mset/set_mp, mdiv/div_mp, mdiv16/div16_mp, madd/add
000C56  1               ;
000C56  1               ; Globals:     Uses n (16-bit) from atan_mp, mp_a, mp_x
000C56  1               ;
000C56  1               ; C Algorithm:
000C56  1               ;
000C56  1               ; int n = 1;
000C56  1               ; setbig(A, 1, 0);
000C56  1               ; setbig(X, 1, 0);
000C56  1               ; while(divbig(X, n++))         // while(dividend != 0)
000C56  1               ;     addbig(A, X);
000C56  1               
000C56  1  A9 00        e:	lda	#0		; n = 0
000C58  1  8D DD 0C     	sta	n
000C5B  1  8D DE 0C     	sta	n+1
000C5E  1  8D 13 E1 AD  	mset	mp_a,#1		; mp_a = 1
000C62  1  D6 0B AC D7  
000C66  1  0B A2 01 20  
000C6A  1  CD 18 8D 13  
000C6E  1  E2           
000C6F  1  8D 13 E1 AD  	mset	mp_x,#1		; mp_x = 1
000C73  1  DA 0B AC DB  
000C77  1  0B A2 01 20  
000C7B  1  CD 18 8D 13  
000C7F  1  E2           
000C80  1               e_mp_loop:
000C80  1  EE DD 0C     	inc	n		; n = n + 1
000C83  1  D0 03        	bne	:+		; n not zero
000C85  1  EE DE 0C     	inc	n+1		; n rolled to 0, inc n (hi)
000C88  1  AE DE 0C     :	ldx	n+1		; if n < 256 then div else div16
000C8B  1  D0 16        	bne	:+		; >= 256 use 16 bit div
000C8D  1  8D 18 E1 AD  	mdiv	mp_x,n		; < 256 use 8 bit div
000C91  1  DA 0B AC DB  
000C95  1  0B AE DD 0C  
000C99  1  20 65 0F 8D  
000C9D  1  18 E2        
000C9F  1  B0 39        	bcs	e_mp_end	; dividend = 0, done
000CA1  1  90 1B        	bcc	:++		; still working on it
000CA3  1  8D 19 E1 AD  :	mdiv16	mp_x,n		; div16
000CA7  1  DD 0C AC DE  
000CAB  1  0C 84 08 85  
000CAF  1  09 AD DA 0B  
000CB3  1  AC DB 0B 20  
000CB7  1  5D 11 8D 19  
000CBB  1  E2           
000CBC  1  B0 1C        	bcs	e_mp_end	; dividend = 0, done
000CBE  1  8D 16 E1 AD  :	madd	mp_a,mp_x	; a = a + x
000CC2  1  DA 0B AC DB  
000CC6  1  0B 85 02 84  
000CCA  1  03 AD D6 0B  
000CCE  1  AC D7 0B 20  
000CD2  1  16 0E 8D 16  
000CD6  1  E2           
000CD7  1  4C 80 0C     	jmp	e_mp_loop
000CDA  1               e_mp_end:
000CDA  1  60           	rts
000CDB  1               
000CDB  1               
000CDB  1               ; Description: Compute arctan(1/N) using the Gregory expansion of Machin's
000CDB  1               ;              arctan formula and save in array (ptr_a).
000CDB  1               ;
000CDB  1               ;
000CDB  1               ;                              / 1     1      1       \
000CDB  1               ;              arctan(1/N) =  |  - - ---- + ---- - ... |
000CDB  1               ;                             |  N      3      5       |
000CDB  1               ;                              \     3xN    5xN       /
000CDB  1               ;
000CDB  1               ;
000CDB  1               ; Input:       Y/A (hi/lo) pointer to array
000CDB  1               ;              X = N (8 bit)
000CDB  1               ;
000CDB  1               ; Output:      Y/A (hi/lo) pointer to array = arctan(1/N)
000CDB  1               ;
000CDB  1               ; Clobbered:   A, X, Y
000CDB  1               ;
000CDB  1               ; Calls:       mset/set_mp, mdiv/div_mp, madd/add_mp, msub/sub_mp,
000CDB  1               ;              mdiv16/div16_mp, mcopy/copy_mp
000CDB  1               ;
000CDB  1               ; Globals:     mp_x (16-bit), mp_y (16-bit)
000CDB  1               ;
000CDB  1               ; C Algorithm:
000CDB  1               ;
000CDB  1               ; void atanbig(bignum A, unsigned short x)
000CDB  1               ; {
000CDB  1               ;     bignum X, Y;
000CDB  1               ;     unsigned short n = 1;
000CDB  1               ;
000CDB  1               ;     setbig(X, 1, 0);
000CDB  1               ;     divbig(X, x);
000CDB  1               ;     copybig(A, X);
000CDB  1               ;     x *= x;
000CDB  1               ;     while (1) {
000CDB  1               ;         n += 2;
000CDB  1               ;         divbig(X, x);
000CDB  1               ;         copybig(Y, X);
000CDB  1               ;         if (!divbig(Y, n))      // dividend = 0
000CDB  1               ;             break;
000CDB  1               ;         if (n & 2)
000CDB  1               ;             subbig(A, Y);
000CDB  1               ;         else
000CDB  1               ;             addbig(A, Y);
000CDB  1               ;     }
000CDB  1               ; }
000CDB  1               ;
000CDB  1               ; Locals (not really):
000CDB  1               
000CDB  1  00           regx:	.byte	$0
000CDC  1  00           x2:	.byte	$0		; x^2 if x < 16
000CDD  1  00 00        n:	.byte	$0, $0
000CDF  1  00 00        ptr_a:	.byte	$0, $0
000CE1  1               squares:
000CE1  1  00 01 04 09  	.byte	0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
000CE5  1  10 19 24 31  
000CE9  1  40 51 64     
000CEC  1  79 90 A9 C4  	.byte	121, 144, 169, 196, 225
000CF0  1  E1           
000CF1  1               
000CF1  1               atan_mp:
000CF1  1  8D DF 0C     	sta	ptr_a		; store ptr lo from A
000CF4  1  8C E0 0C     	sty	ptr_a+1		; store ptr hi from Y
000CF7  1  8E DB 0C     	stx	regx		; save x
000CFA  1               
000CFA  1  A9 00        	lda	#0		; n = 1
000CFC  1  8D DD 0C     	sta	n
000CFF  1  8D DE 0C     	sta	n+1
000D02  1  EE DD 0C     	inc	n		; n = 1 little endian
000D05  1               
000D05  1  8D 13 E1 AD  	mset	mp_x,#1		; mp_x = 1
000D09  1  DA 0B AC DB  
000D0D  1  0B A2 01 20  
000D11  1  CD 18 8D 13  
000D15  1  E2           
000D16  1  8D 18 E1 AD  	mdiv	mp_x,regx	; mp_x /= regx
000D1A  1  DA 0B AC DB  
000D1E  1  0B AE DB 0C  
000D22  1  20 65 0F 8D  
000D26  1  18 E2        
000D28  1  8D 14 E1 AD  	mcopy	ptr_a,mp_x	; ptr_a = mp_x
000D2C  1  DF 0C AC E0  
000D30  1  0C 85 02 84  
000D34  1  03 AD DA 0B  
000D38  1  AC DB 0B 20  
000D3C  1  DD 0E 8D 14  
000D40  1  E2           
000D41  1               
000D41  1  AE DB 0C     	ldx	regx		; square x if x < 16
000D44  1  8E DC 0C     	stx	x2
000D47  1  E0 10        	cpx	#16
000D49  1  B0 06        	bcs	atan_mp_loop
000D4B  1  BD E1 0C     	lda	squares,x	; load from squares table
000D4E  1  8D DC 0C     	sta	x2		;   and save
000D51  1               
000D51  1               atan_mp_loop:			; main loop
000D51  1               				; n = n + 2
000D51  1  EE DD 0C     	inc	n		; n now even
000D54  1  D0 03        	bne	:+		; n not zero
000D56  1  EE DE 0C     	inc	n+1		; n rolled to 0, inc n (hi)
000D59  1  EE DD 0C     :	inc	n		; n to be odd, save to inc (cannot roll from
000D5C  1               				;   even to odd)
000D5C  1  AE DB 0C     	ldx	regx		; x = x / regx ^ 2
000D5F  1  E0 10        	cpx	#16
000D61  1  90 12        	bcc	:+		; x already x*x, one div required
000D63  1  8D 18 E1 AD  	mdiv	mp_x,x2		; x >= 16, then do two div
000D67  1  DA 0B AC DB  
000D6B  1  0B AE DC 0C  
000D6F  1  20 65 0F 8D  
000D73  1  18 E2        
000D75  1  8D 18 E1 AD  :	mdiv	mp_x,x2		;   (faster than 16 bit div)
000D79  1  DA 0B AC DB  
000D7D  1  0B AE DC 0C  
000D81  1  20 65 0F 8D  
000D85  1  18 E2        
000D87  1               
000D87  1  8D 14 E1 AD  	mcopy	mp_y,mp_x	; y = x
000D8B  1  DC 0B AC DD  
000D8F  1  0B 85 02 84  
000D93  1  03 AD DA 0B  
000D97  1  AC DB 0B 20  
000D9B  1  DD 0E 8D 14  
000D9F  1  E2           
000DA0  1               
000DA0  1  AE DE 0C     	ldx	n+1		; if n < 256 then div else div16
000DA3  1  D0 16        	bne	:+		; >= 256 use 16 bit div
000DA5  1  8D 18 E1 AD  	mdiv	mp_y,n		; < 256 use 8 bit div
000DA9  1  DC 0B AC DD  
000DAD  1  0B AE DD 0C  
000DB1  1  20 65 0F 8D  
000DB5  1  18 E2        
000DB7  1  B0 5C        	bcs	atan_mp_end	; dividend = 0, done
000DB9  1  90 1B        	bcc	:++		; still working on it
000DBB  1  8D 19 E1 AD  :	mdiv16	mp_y,n		; div16
000DBF  1  DD 0C AC DE  
000DC3  1  0C 84 08 85  
000DC7  1  09 AD DC 0B  
000DCB  1  AC DD 0B 20  
000DCF  1  5D 11 8D 19  
000DD3  1  E2           
000DD4  1  B0 3F        	bcs	atan_mp_end	; dividend = 0, done
000DD6  1               
000DD6  1  AD DD 0C     :	lda	n		; add or sub
000DD9  1  29 02        	and	#2
000DDB  1  F0 1C        	beq	:+		; add it
000DDD  1  8D 17 E1 AD  	msub	ptr_a,mp_y	; a = a - y
000DE1  1  DC 0B AC DD  
000DE5  1  0B 85 02 84  
000DE9  1  03 AD DF 0C  
000DED  1  AC E0 0C 20  
000DF1  1  5D 0E 8D 17  
000DF5  1  E2           
000DF6  1  4C 51 0D     	jmp	atan_mp_loop
000DF9  1  8D 16 E1 AD  :	madd	ptr_a,mp_y	; a = a + y
000DFD  1  DC 0B AC DD  
000E01  1  0B 85 02 84  
000E05  1  03 AD DF 0C  
000E09  1  AC E0 0C 20  
000E0D  1  16 0E 8D 16  
000E11  1  E2           
000E12  1  4C 51 0D     	jmp	atan_mp_loop
000E15  1               atan_mp_end:
000E15  1  60           	rts
000E16  1               
000E16  1               
000E16  1               ; Description: Multiprecision add:  a = a + b
000E16  1               ;
000E16  1               ; Input:       Y/A (hi/lo) pointer to array (a)
000E16  1               ;              ptr_mp set by macro to point to array (b)
000E16  1               ;
000E16  1               ; Output:      a = a + b
000E16  1               ;
000E16  1               ; Clobbered:   A, X, Y
000E16  1               ;
000E16  1               ; Globals:     arraylen (16-bit), arrayend (16-bit), zp ptr (16-bit),
000E16  1               ;              zp ptr_mp (16-bit)
000E16  1               
000E16  1               add_mp:
000E16  1  85 00        	sta	ptr		; store ptr lo from A
000E18  1  98           	tya
000E19  1  18           	clc
000E1A  1  6D D3 0B     	adc	arrayend+1	; add number of pages since we have to go
000E1D  1  85 01        	sta	ptr+1		;   backwards for add/sub/asl
000E1F  1  A5 03        	lda	ptr_mp+1
000E21  1  18           	clc
000E22  1  6D D3 0B     	adc	arrayend+1	; add number of pages since we have to go
000E25  1  85 03        	sta	ptr_mp+1	;   backwards for add/sub/asl
000E27  1  AE D3 0B     	ldx	arrayend+1	; full pages
000E2A  1  AC D2 0B     	ldy	arrayend	; partial
000E2D  1  18           	clc			; clear carry for many adds
000E2E  1  98           	tya
000E2F  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
000E31  1  F0 16        	beq	@1		;   even (arrayend odd), so just need to
000E33  1  D0 06        	bne	@3		;   check for 2nd bit (odd or even # of pairs).
000E35  1  CA           :	dex
000E36  1  C6 01        	dec	ptr+1		; previous page of 256
000E38  1  C6 03        	dec	ptr_mp+1	; previous page of 256
000E3A  1  88           :	dey
000E3B  1  B1 00        @3:	lda	(ptr),y		; a	; do bytes 3,4,...,255
000E3D  1  71 02        	adc	(ptr_mp),y	; + b
000E3F  1  91 00        	sta	(ptr),y		; a = a + b
000E41  1  88           	dey
000E42  1  B1 00        @2:	lda	(ptr),y		; a	; do bytes 2,4,...,254
000E44  1  71 02        	adc	(ptr_mp),y	; + b
000E46  1  91 00        	sta	(ptr),y		; a = a + b
000E48  1  88           	dey
000E49  1  B1 00        @1:	lda	(ptr),y		; a	; do bytes 1,5,...,253
000E4B  1  71 02        	adc	(ptr_mp),y	; + b
000E4D  1  91 00        	sta	(ptr),y		; a = a + b
000E4F  1  88           	dey
000E50  1  B1 00        @0:	lda	(ptr),y		; a	; do bytes 0,4,...,252
000E52  1  71 02        	adc	(ptr_mp),y	; + b
000E54  1  91 00        	sta	(ptr),y		; a = a + b
000E56  1  98           	tya
000E57  1  D0 E1        	bne	:-
000E59  1  8A           	txa
000E5A  1  D0 D9        	bne	:--
000E5C  1  60           	rts
000E5D  1               
000E5D  1               
000E5D  1               ; Description: Multiprecision subtract:  a = a - b
000E5D  1               ;
000E5D  1               ; Input:       Y/A (hi/lo) pointer to array (a)
000E5D  1               ;              ptr_mp set by macro to point to array (b)
000E5D  1               ;
000E5D  1               ; Output:      a = a - b
000E5D  1               ;
000E5D  1               ; Clobbered:   A, X, Y
000E5D  1               ;
000E5D  1               ; Globals:     arraylen (16-bit), arrayend (16-bit), zp ptr (16-bit),
000E5D  1               ;              zp ptr_mp (16-bit)
000E5D  1               
000E5D  1               sub_mp:
000E5D  1  85 00        	sta	ptr		; store ptr lo from A
000E5F  1  98           	tya
000E60  1  18           	clc
000E61  1  6D D3 0B     	adc	arrayend+1	; add number of pages since we have to go
000E64  1  85 01        	sta	ptr+1		;   backwards for add/sub/asl
000E66  1  A5 03        	lda	ptr_mp+1
000E68  1  18           	clc
000E69  1  6D D3 0B     	adc	arrayend+1	; add number of pages since we have to go
000E6C  1  85 03        	sta	ptr_mp+1	;   backwards for add/sub/asl
000E6E  1  AE D3 0B     	ldx	arrayend+1	; full pages
000E71  1  AC D2 0B     	ldy	arrayend	; partial
000E74  1  38           	sec			; sec carry for many subs
000E75  1  98           	tya
000E76  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
000E78  1  F0 16        	beq	@1		;   even (arrayend odd), so just need to
000E7A  1  D0 06        	bne	@3		;   check for 2nd bit (odd or even # of pairs).
000E7C  1  CA           :	dex
000E7D  1  C6 01        	dec	ptr+1		; previous page of 256
000E7F  1  C6 03        	dec	ptr_mp+1	; previous page of 256
000E81  1  88           :	dey
000E82  1  B1 00        @3:	lda	(ptr),y		; a	; do bytes 3,7,...,255
000E84  1  F1 02        	sbc	(ptr_mp),y	; - b
000E86  1  91 00        	sta	(ptr),y		; a = a - b
000E88  1  88           	dey
000E89  1  B1 00        @2:	lda	(ptr),y		; a	; do bytes 2,6,...,254
000E8B  1  F1 02        	sbc	(ptr_mp),y	; - b
000E8D  1  91 00        	sta	(ptr),y		; a = a - b
000E8F  1  88           	dey
000E90  1  B1 00        @1:	lda	(ptr),y		; a	; do bytes 1,5,...,253
000E92  1  F1 02        	sbc	(ptr_mp),y	; - b
000E94  1  91 00        	sta	(ptr),y		; a = a - b
000E96  1  88           	dey
000E97  1  B1 00        @0:	lda	(ptr),y		; a	; do bytes 0,4,...,252
000E99  1  F1 02        	sbc	(ptr_mp),y	; - b
000E9B  1  91 00        	sta	(ptr),y		; a = a - b
000E9D  1  98           	tya
000E9E  1  D0 E1        	bne	:-
000EA0  1  8A           	txa
000EA1  1  D0 D9        	bne	:--
000EA3  1  60           	rts
000EA4  1               
000EA4  1               
000EA4  1               ; Description: Multiprecision shift left:  a = a * 2
000EA4  1               ;
000EA4  1               ; Input:       Y/A (hi/lo) pointer to array (a)
000EA4  1               ;
000EA4  1               ; Output:      a = a * 2
000EA4  1               ;
000EA4  1               ; Clobbered:   A, X, Y
000EA4  1               ;
000EA4  1               ; Globals:     arraylen (16-bit), arrayend (16-bit), zp ptr (16-bit),
000EA4  1               
000EA4  1               asl_mp:
000EA4  1  85 00        	sta	ptr		; store ptr lo from A
000EA6  1  98           	tya
000EA7  1  18           	clc
000EA8  1  6D D3 0B     	adc	arrayend+1	; add number of pages since we have to go
000EAB  1  85 01        	sta	ptr+1		;   backwards for add/sub/asl
000EAD  1  AE D3 0B     	ldx	arrayend+1	; full pages
000EB0  1  AC D2 0B     	ldy	arrayend	; partial
000EB3  1  18           	clc			; clear carry for many rols
000EB4  1  98           	tya
000EB5  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
000EB7  1  F0 12        	beq	@1		;   even (arrayend odd), so just need to
000EB9  1  D0 04        	bne	@3		;   check for 2nd bit (odd or even # of pairs).
000EBB  1  CA           :	dex
000EBC  1  C6 01        	dec	ptr+1		; previous page of 256
000EBE  1  88           :	dey
000EBF  1  B1 00        @3:	lda	(ptr),y		; do bytes 3,7,...,255
000EC1  1  2A           	rol
000EC2  1  91 00        	sta	(ptr),y
000EC4  1  88           	dey
000EC5  1  B1 00        @2:	lda	(ptr),y		; do bytes 2,6,...,254
000EC7  1  2A           	rol
000EC8  1  91 00        	sta	(ptr),y
000ECA  1  88           	dey
000ECB  1  B1 00        @1:	lda	(ptr),y		; do bytes 1,5,...,253
000ECD  1  2A           	rol
000ECE  1  91 00        	sta	(ptr),y
000ED0  1  88           	dey
000ED1  1  B1 00        @0:	lda	(ptr),y		; do bytes 0,4,...,252
000ED3  1  2A           	rol
000ED4  1  91 00        	sta	(ptr),y
000ED6  1  98           	tya
000ED7  1  D0 E5        	bne	:-
000ED9  1  8A           	txa
000EDA  1  D0 DF        	bne	:--
000EDC  1  60           	rts
000EDD  1               
000EDD  1               
000EDD  1               ; Description: Multiprecision transfer:  a = b
000EDD  1               ;
000EDD  1               ; Input:       Y/A (hi/lo) pointer to array (b)
000EDD  1               ;              ptr_mp set by macro to point to array (a)
000EDD  1               ;
000EDD  1               ; Output:      a = b
000EDD  1               ;
000EDD  1               ; Clobbered:   A, X, Y
000EDD  1               ;
000EDD  1               ; Globals:     arraylen (16-bit), zp ptr (16-bit), zp ptr_mp (16-bit)
000EDD  1               
000EDD  1               copy_mp:
000EDD  1  85 00        	sta	ptr		; store ptr lo from A
000EDF  1  84 01        	sty	ptr+1		; store ptr hi from Y
000EE1  1  AE D1 0B     	ldx	arraylen+1	; full pages
000EE4  1  AC D0 0B     	ldy	arraylen	; partial pages
000EE7  1  F0 1E        	beq	@0		;   if not process full pages only
000EE9  1  E8           	inx			; bump up x +1 for the partial page
000EEA  1  18           	clc			; adjust to point below source start
000EEB  1  98           	tya			; - ex: ptr = $xx00, arraylen = 1
000EEC  1  65 00        	adc	ptr		; we want ptr = $(xx-1)01, y = $ff (255)
000EEE  1  85 00        	sta	ptr
000EF0  1  B0 02        	bcs	:+
000EF2  1  C6 01        	dec	ptr+1
000EF4  1  18           :	clc			; adjust to point below destination start
000EF5  1  98           	tya			; - ex: ptr_mp = $xxff, arraylen = 2
000EF6  1  65 02        	adc	ptr_mp		; we want ptr_mp = $xx01, y = $fe (254)
000EF8  1  85 02        	sta	ptr_mp
000EFA  1  B0 02        	bcs	:+
000EFC  1  C6 03        	dec	ptr_mp+1
000EFE  1  98           :	tya			; adjust y index value, y = -y
000EFF  1  49 FF        	eor	#$ff		; one's complement
000F01  1  A8           	tay
000F02  1  C8           	iny			; two's complement
000F03  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
000F05  1  F0 0A        	beq	@2		;   even, so just need to check for 2nd bit
000F07  1               				;   (odd or even # of pairs).
000F07  1               				;   Fall through to @0.
000F07  1               				; NOTE: A = Y - 1, checking A, not Y
000F07  1               				; if A & %11 = 1, then Y%3 = 2
000F07  1               				; if A & %11 = 3, then Y%3 = 0
000F07  1  B1 00        @0:	lda	(ptr),y		; move bytes 0,4,...,252
000F09  1  91 02        	sta	(ptr_mp),y
000F0B  1  C8           	iny
000F0C  1  B1 00        @1:	lda	(ptr),y		; move bytes 1,5,...,253
000F0E  1  91 02        	sta	(ptr_mp),y
000F10  1  C8           	iny
000F11  1  B1 00        @2:	lda	(ptr),y		; move bytes 2,6,...,254
000F13  1  91 02        	sta	(ptr_mp),y
000F15  1  C8           	iny
000F16  1  B1 00        @3:	lda	(ptr),y		; move bytes 3,7,...,255
000F18  1  91 02        	sta	(ptr_mp),y
000F1A  1  C8           	iny			; page done ?
000F1B  1  D0 EA        	bne	@0		; b: no
000F1D  1  E6 01        	inc	ptr+1		; next page
000F1F  1  E6 03        	inc	ptr_mp+1
000F21  1  CA           	dex			; full page left ?
000F22  1  D0 E3        	bne	@0		; b:yes
000F24  1  60           	rts
000F25  1               
000F25  1               
000F25  1               ; Description: Skip leading zeros (used by div_mp and div16_mp)
000F25  1               ;
000F25  1               ; Input:       Y/A (hi/lo) pointer to array (b)
000F25  1               ;
000F25  1               ; Output:      None
000F25  1               ;
000F25  1               ; Clobbered:   A, X, Y
000F25  1               ;
000F25  1               ; Globals:     arraylen (16-bit), zp ptr (16-bit)
000F25  1               
000F25  1               skipzeros:
000F25  1  85 00        	sta	ptr		; store ptr lo from A
000F27  1  84 01        	sty	ptr+1		; store ptr hi from Y
000F29  1  AE D1 0B     	ldx	arraylen+1	; full pages
000F2C  1  AC D0 0B     	ldy	arraylen	; partial pages ?
000F2F  1  F0 14        	beq	@0		; b:no - process full pages only
000F31  1  E8           	inx			; bump up x +1 for the partial page
000F32  1  18           	clc			; adjust to point below source start
000F33  1  98           	tya			; - ex: ptr = $xx00, arraylen = 1
000F34  1  65 00        	adc	ptr		; we want ptr = $(xx-1)01, y = $ff (255)
000F36  1  85 00        	sta	ptr
000F38  1  B0 02        	bcs	:+
000F3A  1  C6 01        	dec	ptr+1
000F3C  1  98           :	tya			; adjust y index value, y = -y
000F3D  1  49 FF        	eor	#$ff		; one's complement
000F3F  1  A8           	tay
000F40  1  C8           	iny			; two's complement
000F41  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
000F43  1  F0 0A        	beq	@2		;   even, so just need to check for 2nd bit
000F45  1               				;   (odd or even # of pairs).
000F45  1               				;   Fall through to @0.
000F45  1               				; NOTE: A = Y - 1, checking A, not Y
000F45  1               				; if A & %11 = 1, then Y%3 = 2
000F45  1               				; if A & %11 = 3, then Y%3 = 0
000F45  1  B1 00        @0:	lda	(ptr),y		; check	0,4,...,252
000F47  1  D0 1A        	bne	@5
000F49  1  C8           	iny
000F4A  1  B1 00        @1:	lda	(ptr),y		; check 1,5,...,253
000F4C  1  D0 14        	bne	@4
000F4E  1  C8           	iny
000F4F  1  B1 00        @2:	lda	(ptr),y		; check 2,6,...,254
000F51  1  D0 10        	bne	@5
000F53  1  C8           	iny
000F54  1  B1 00        @3:	lda	(ptr),y		; check 3,7,...,255
000F56  1  D0 0A        	bne	@4
000F58  1  C8           	iny
000F59  1  D0 EA        	bne	@0
000F5B  1  E6 01        	inc	ptr+1		; next page
000F5D  1  CA           	dex			; is there another page ?
000F5E  1  D0 E5        	bne	@0		; b:yes
000F60  1  38           	sec			; flag: all cells are zero
000F61  1  60           	rts
000F62  1  88           @4:	dey			; make Y even
000F63  1  18           @5:	clc			; flag: (ptr),y -> first non-zero cell
000F64  1  60           	rts
000F65  1               
000F65  1               
000F65  1               ; Description: 16-bit/8-bit divide based on:
000F65  1               ;              http://6502org.wikidot.com/software-math-intdiv
000F65  1               ;
000F65  1               ; Input:       divisor (8-bit), dividend (16-bit) hi: X, lo: dividend
000F65  1               ;
000F65  1               ; Output:      divisor (8-bit) unchanged,
000F65  1               ;              X: remainder (8-bit),
000F65  1               ;              dividend (8-bit): quotient
000F65  1               ;
000F65  1               ; Clobbered:   A, X
000F65  1               
000F65  1               .macro	div8
000F65  1               cnton 60
000F65  1               
000F65  1               	txa			; remainder
000F65  1               	asl	dividend
000F65  1               	.repeat 8		; unroll 8 times for speed
000F65  1               	rol
000F65  1               	bcs	:+
000F65  1               	cmp	divisor
000F65  1               	bcc	:++
000F65  1               :	sbc	divisor
000F65  1               	sec
000F65  1               :	rol	dividend
000F65  1               	.endrepeat
000F65  1               	tax			; remainder
000F65  1               
000F65  1               cntoff 60
000F65  1               .endmacro
000F65  1               
000F65  1               
000F65  1               ; Description: Divide mp array by 8-bit number.
000F65  1               ;
000F65  1               ; Input:       Y(hi)/A(lo) pointer to mp
000F65  1               ;              X = dividend/denominator
000F65  1               ;
000F65  1               ; Output:      (ptr) = (ptr)/x
000F65  1               ;
000F65  1               ; Clobbered:   A, X, Y
000F65  1               ;
000F65  1               ; Globals:     zp ptr (16-bit), arraylen (16-bit), dividend (8-bit),
000F65  1               ;              zp xreg (8-bit),
000F65  1               ;
000F65  1               ; Calls:       skipzeros, div8(macro)
000F65  1               ;
000F65  1               ; C Algorithm:
000F65  1               ;
000F65  1               ; short divbig(number, x)
000F65  1               ; bignum number;
000F65  1               ; unsigned short x;
000F65  1               ; {
000F65  1               ;     dword result;
000F65  1               ;     short j = 0;
000F65  1               ;     unsigned short rest = 0;
000F65  1               ;
000F65  1               ;     while (number[j] == 0 && j < MAXSIZE)
000F65  1               ;         j++;
000F65  1               ;     if (j == MAXSIZE)
000F65  1               ;         return (0);
000F65  1               ;     while (j < MAXSIZE) {
000F65  1               ;         result.w.lo = number[j];
000F65  1               ;         result.w.hi = rest;
000F65  1               ;         number[j] = result.L / x;
000F65  1               ;         rest = result.L % x;
000F65  1               ;         j++;
000F65  1               ;     }
000F65  1               ;     return (1);
000F65  1               ; }
000F65  1               
000F65  1               div_mp:
000F65  1  86 08        	stx	divisor		; save divisor
000F67  1  20 25 0F     	jsr	skipzeros	; skip leading zeros for speed
000F6A  1  90 01        	bcc	:+		; carry clear?  continue
000F6C  1  60           	rts			;   else all zeros, return to caller
000F6D  1  86 0B        :	stx	xreg		; need x reg for speed (carry)
000F6F  1  A2 00        	ldx	#0
000F71  1  98           	tya
000F72  1  29 03        	and	#%11
000F74  1  F0 0B        	beq	@0		; 00 & 11 = 0
000F76  1  4A           	lsr			; 00 => 0,0; 01 => 0,1; 10 => 1,0; 11 => 1,1
000F77  1  F0 7B        	beq	@1		; 01 => 0,1
000F79  1               	;bcc	@2		; 1,0
000F79  1  90 03        	bcc	:+		; long branch
000F7B  1               	;bcs	@3		; 1,1
000F7B  1  4C DA 10     	jmp	@3		; long branch
000F7E  1  4C 67 10     :	jmp	@2
000F81  1  B1 00        @0:	lda	(ptr),y		; div byte 0,4,...,252
000F83  1  85 04        	sta	dividend
000F85  1  8D 3C E1 8A  	div8
000F89  1  06 04 2A B0  
000F8D  1  04 C5 08 90  
000F91  1  03 E5 08 38  
000F95  1  26 04 2A B0  
000F99  1  04 C5 08 90  
000F9D  1  03 E5 08 38  
000FA1  1  26 04 2A B0  
000FA5  1  04 C5 08 90  
000FA9  1  03 E5 08 38  
000FAD  1  26 04 2A B0  
000FB1  1  04 C5 08 90  
000FB5  1  03 E5 08 38  
000FB9  1  26 04 2A B0  
000FBD  1  04 C5 08 90  
000FC1  1  03 E5 08 38  
000FC5  1  26 04 2A B0  
000FC9  1  04 C5 08 90  
000FCD  1  03 E5 08 38  
000FD1  1  26 04 2A B0  
000FD5  1  04 C5 08 90  
000FD9  1  03 E5 08 38  
000FDD  1  26 04 2A B0  
000FE1  1  04 C5 08 90  
000FE5  1  03 E5 08 38  
000FEF  1  A5 04        	lda	dividend
000FF1  1  91 00        	sta	(ptr),y
000FF3  1  C8           	iny
000FF4  1  B1 00        @1:	lda	(ptr),y		; div byte 1,5,...,253
000FF6  1  85 04        	sta	dividend
000FF8  1  8D 3C E1 8A  	div8
000FFC  1  06 04 2A B0  
001000  1  04 C5 08 90  
001004  1  03 E5 08 38  
001008  1  26 04 2A B0  
00100C  1  04 C5 08 90  
001010  1  03 E5 08 38  
001014  1  26 04 2A B0  
001018  1  04 C5 08 90  
00101C  1  03 E5 08 38  
001020  1  26 04 2A B0  
001024  1  04 C5 08 90  
001028  1  03 E5 08 38  
00102C  1  26 04 2A B0  
001030  1  04 C5 08 90  
001034  1  03 E5 08 38  
001038  1  26 04 2A B0  
00103C  1  04 C5 08 90  
001040  1  03 E5 08 38  
001044  1  26 04 2A B0  
001048  1  04 C5 08 90  
00104C  1  03 E5 08 38  
001050  1  26 04 2A B0  
001054  1  04 C5 08 90  
001058  1  03 E5 08 38  
001062  1  A5 04        	lda	dividend
001064  1  91 00        	sta	(ptr),y
001066  1  C8           	iny
001067  1  B1 00        @2:	lda	(ptr),y		; div byte 2,6,...,254
001069  1  85 04        	sta	dividend
00106B  1  8D 3C E1 8A  	div8
00106F  1  06 04 2A B0  
001073  1  04 C5 08 90  
001077  1  03 E5 08 38  
00107B  1  26 04 2A B0  
00107F  1  04 C5 08 90  
001083  1  03 E5 08 38  
001087  1  26 04 2A B0  
00108B  1  04 C5 08 90  
00108F  1  03 E5 08 38  
001093  1  26 04 2A B0  
001097  1  04 C5 08 90  
00109B  1  03 E5 08 38  
00109F  1  26 04 2A B0  
0010A3  1  04 C5 08 90  
0010A7  1  03 E5 08 38  
0010AB  1  26 04 2A B0  
0010AF  1  04 C5 08 90  
0010B3  1  03 E5 08 38  
0010B7  1  26 04 2A B0  
0010BB  1  04 C5 08 90  
0010BF  1  03 E5 08 38  
0010C3  1  26 04 2A B0  
0010C7  1  04 C5 08 90  
0010CB  1  03 E5 08 38  
0010D5  1  A5 04        	lda	dividend
0010D7  1  91 00        	sta	(ptr),y
0010D9  1  C8           	iny
0010DA  1  B1 00        @3:	lda	(ptr),y		; div byte 3,7,...,255
0010DC  1  85 04        	sta	dividend
0010DE  1  8D 3C E1 8A  	div8
0010E2  1  06 04 2A B0  
0010E6  1  04 C5 08 90  
0010EA  1  03 E5 08 38  
0010EE  1  26 04 2A B0  
0010F2  1  04 C5 08 90  
0010F6  1  03 E5 08 38  
0010FA  1  26 04 2A B0  
0010FE  1  04 C5 08 90  
001102  1  03 E5 08 38  
001106  1  26 04 2A B0  
00110A  1  04 C5 08 90  
00110E  1  03 E5 08 38  
001112  1  26 04 2A B0  
001116  1  04 C5 08 90  
00111A  1  03 E5 08 38  
00111E  1  26 04 2A B0  
001122  1  04 C5 08 90  
001126  1  03 E5 08 38  
00112A  1  26 04 2A B0  
00112E  1  04 C5 08 90  
001132  1  03 E5 08 38  
001136  1  26 04 2A B0  
00113A  1  04 C5 08 90  
00113E  1  03 E5 08 38  
001148  1  A5 04        	lda	dividend
00114A  1  91 00        	sta	(ptr),y
00114C  1  C8           	iny			; page done ?
00114D  1  F0 03        	beq	:+
00114F  1  4C 81 0F     	jmp	@0
001152  1  C6 0B        :	dec	xreg		; full page left ?
001154  1  F0 05        	beq	:+
001156  1  E6 01        	inc	ptr+1		; next page
001158  1  4C 81 0F     	jmp	@0
00115B  1  18           :	clc			; non zero result
00115C  1  60           	rts
00115D  1               
00115D  1               
00115D  1               ; Description: 32-bit/16-bit divide based on:
00115D  1               ;              Apple II firmware (Steve Wozniak) and
00115D  1               ;              http://www.txbobsc.com/aal/1983/aal8303.html#a5, and
00115D  1               ;              optimized by Anton Treuenfels.
00115D  1               ;
00115D  1               ; Input:       divisor (16-bit big endian), dividend (32-bit big endian)
00115D  1               ;
00115D  1               ; Output:      divisor (16-bit big endian) unchanged,
00115D  1               ;              dividend (32-bit big endian) hi: remainder
00115D  1               ;              dividend (32-bit big endian) lo: quotient
00115D  1               ;
00115D  1               ; Clobbered:   A, X, Y
00115D  1               
00115D  1               .macro	div16
00115D  1               	ldx	dividend+1	; remainder
00115D  1               	ldy	dividend+0	; remainder
00115D  1               	.repeat 16		; unroll 16 times for speed
00115D  1               	asl	dividend+3	; 5
00115D  1               	rol	dividend+2	; 10
00115D  1               	txa			; 12
00115D  1               	rol			; 14
00115D  1               	tax			; 16
00115D  1               	tya			; 18
00115D  1               	rol			; 20
00115D  1               	tay			; 22
00115D  1               	cpx	divisor+1	; 25
00115D  1               	sbc	divisor+0	; 28
00115D  1               	bcc	:+		; 30/31 (no subtraction)
00115D  1               	tay			; 32
00115D  1               	txa			; 34
00115D  1               	sbc	divisor+1	; 37
00115D  1               	tax			; 39
00115D  1               	inc	dividend+3	; 44 (subtraction)
00115D  1               :
00115D  1               	.endrepeat
00115D  1               	stx	dividend+1	; remainder
00115D  1               	sty	dividend+0	; remainder
00115D  1               .endmacro
00115D  1               
00115D  1               
00115D  1               ; Description: Divide mp array by 16-bit number.
00115D  1               ;
00115D  1               ; Input:       Y(hi)/A(lo) pointer to mp
00115D  1               ;              divisor (16-bit) set by macro
00115D  1               ;
00115D  1               ; Output:      (ptr) = (ptr)/divisor
00115D  1               ;
00115D  1               ; Clobbered:   A, X, Y
00115D  1               ;
00115D  1               ; Globals:     zp ptr (16-bit), arraylen (16-bit), dividend (32-bit),
00115D  1               ;              zp xreg (8-bit), divisor (16-bit)
00115D  1               ;
00115D  1               ; Calls:       skipzeros, div16(macro), div16_long(macro)
00115D  1               ;
00115D  1               ; C Algorithm: see div_mp
00115D  1               
00115D  1               .macro	div16_long
00115D  1               	lda	(ptr),y		; load/store LSB of dividend
00115D  1               	sta	dividend+2
00115D  1               	sty	yreg		; save y for updating array
00115D  1               	iny
00115D  1               	lda	(ptr),y		; load/store LSB-1 of dividend
00115D  1               	sta	dividend+3
00115D  1               	div16			; need x and y reg
00115D  1               	ldy	yreg		; restore y
00115D  1               	lda	quotient+0	; load/store quotient MSB to array
00115D  1               	sta	(ptr),y
00115D  1               	iny
00115D  1               	lda	quotient+1	; load/store quotient LSB to array
00115D  1               	sta	(ptr),y
00115D  1               	iny
00115D  1               .endmacro
00115D  1               
00115D  1               div16_mp:
00115D  1  20 25 0F     	jsr	skipzeros	; skip leading zeros for speed
001160  1  90 01        	bcc	:+		; carry clear?  continue
001162  1  60           	rts			;   else all zeros, return to caller
001163  1  A9 00        :	lda	#0		; clear remainder/carry
001165  1  85 04        	sta	dividend+0	; MSB (big endian)
001167  1  85 05        	sta	dividend+1	; MSB-1
001169  1  86 0B        	stx	xreg		; macro div16 needs x reg
00116B  1  98           	tya
00116C  1  4A           	lsr			; even number of non-zero
00116D  1  29 03        	and	#%11		; however there can be an odd number of pairs
00116F  1  F0 0E        	beq	@0		; 00 & 11 = 0
001171  1  4A           	lsr			; 00 => 0,0; 01 => 0,1; 10 => 1,0; 11 => 1,1
001172  1               	;beq	@1		; 01 => 0,1
001172  1  D0 03        	bne	:+
001174  1  4C 0E 13     	jmp	@1
001177  1               :	;bcc	@2		; 1,0
001177  1  90 03        	bcc	:+		; long branch
001179  1               	;bcs	@3		; 1,1
001179  1  4C 2C 16     	jmp	@3		; long branch
00117C  1  4C 9D 14     :	jmp	@2
00117F  1  B1 00 85 06  @0:	div16_long
001183  1  84 0A C8 B1  
001187  1  00 85 07 A6  
00118B  1  05 A4 04 06  
00118F  1  07 26 06 8A  
001193  1  2A AA 98 2A  
001197  1  A8 E4 09 E5  
00119B  1  08 90 07 A8  
00119F  1  8A E5 09 AA  
0011A3  1  E6 07 06 07  
0011A7  1  26 06 8A 2A  
0011AB  1  AA 98 2A A8  
0011AF  1  E4 09 E5 08  
0011B3  1  90 07 A8 8A  
0011B7  1  E5 09 AA E6  
0011BB  1  07 06 07 26  
0011BF  1  06 8A 2A AA  
0011C3  1  98 2A A8 E4  
0011C7  1  09 E5 08 90  
0011CB  1  07 A8 8A E5  
0011CF  1  09 AA E6 07  
0011D3  1  06 07 26 06  
0011D7  1  8A 2A AA 98  
0011DB  1  2A A8 E4 09  
0011DF  1  E5 08 90 07  
00130E  1  B1 00 85 06  @1:	div16_long
001312  1  84 0A C8 B1  
001316  1  00 85 07 A6  
00131A  1  05 A4 04 06  
00131E  1  07 26 06 8A  
001322  1  2A AA 98 2A  
001326  1  A8 E4 09 E5  
00132A  1  08 90 07 A8  
00132E  1  8A E5 09 AA  
001332  1  E6 07 06 07  
001336  1  26 06 8A 2A  
00133A  1  AA 98 2A A8  
00133E  1  E4 09 E5 08  
001342  1  90 07 A8 8A  
001346  1  E5 09 AA E6  
00134A  1  07 06 07 26  
00134E  1  06 8A 2A AA  
001352  1  98 2A A8 E4  
001356  1  09 E5 08 90  
00135A  1  07 A8 8A E5  
00135E  1  09 AA E6 07  
001362  1  06 07 26 06  
001366  1  8A 2A AA 98  
00136A  1  2A A8 E4 09  
00136E  1  E5 08 90 07  
00149D  1  B1 00 85 06  @2:	div16_long
0014A1  1  84 0A C8 B1  
0014A5  1  00 85 07 A6  
0014A9  1  05 A4 04 06  
0014AD  1  07 26 06 8A  
0014B1  1  2A AA 98 2A  
0014B5  1  A8 E4 09 E5  
0014B9  1  08 90 07 A8  
0014BD  1  8A E5 09 AA  
0014C1  1  E6 07 06 07  
0014C5  1  26 06 8A 2A  
0014C9  1  AA 98 2A A8  
0014CD  1  E4 09 E5 08  
0014D1  1  90 07 A8 8A  
0014D5  1  E5 09 AA E6  
0014D9  1  07 06 07 26  
0014DD  1  06 8A 2A AA  
0014E1  1  98 2A A8 E4  
0014E5  1  09 E5 08 90  
0014E9  1  07 A8 8A E5  
0014ED  1  09 AA E6 07  
0014F1  1  06 07 26 06  
0014F5  1  8A 2A AA 98  
0014F9  1  2A A8 E4 09  
0014FD  1  E5 08 90 07  
00162C  1  B1 00 85 06  @3:	div16_long
001630  1  84 0A C8 B1  
001634  1  00 85 07 A6  
001638  1  05 A4 04 06  
00163C  1  07 26 06 8A  
001640  1  2A AA 98 2A  
001644  1  A8 E4 09 E5  
001648  1  08 90 07 A8  
00164C  1  8A E5 09 AA  
001650  1  E6 07 06 07  
001654  1  26 06 8A 2A  
001658  1  AA 98 2A A8  
00165C  1  E4 09 E5 08  
001660  1  90 07 A8 8A  
001664  1  E5 09 AA E6  
001668  1  07 06 07 26  
00166C  1  06 8A 2A AA  
001670  1  98 2A A8 E4  
001674  1  09 E5 08 90  
001678  1  07 A8 8A E5  
00167C  1  09 AA E6 07  
001680  1  06 07 26 06  
001684  1  8A 2A AA 98  
001688  1  2A A8 E4 09  
00168C  1  E5 08 90 07  
0017BB  1  F0 03        	beq	:+		; done?
0017BD  1  4C 7F 11     	jmp	@0
0017C0  1  C6 0B        :	dec	xreg
0017C2  1  F0 05        	beq	:+
0017C4  1  E6 01        	inc	ptr+1		; next page
0017C6  1  4C 7F 11     	jmp	@0
0017C9  1  18           :	clc			; non zero result
0017CA  1  60           	rts
0017CB  1               
0017CB  1               
0017CB  1               ; Description: print mp base 10/100
0017CB  1               ;
0017CB  1               ; Input:       Y(hi)/A(lo) pointer to array
0017CB  1               ;
0017CB  1               ; Output:      mp base 10/100 out to screen
0017CB  1               ;
0017CB  1               ; Clobbered:   A, X, Y, input array
0017CB  1               ;
0017CB  1               ; Globals:     zero page: ptr (16-bit) , ptr_mp (16-bit), carry_mp (8-bit),
0017CB  1               ;              arraylen (16-bit)
0017CB  1               ;
0017CB  1               ; Tables:      512 byte mult100_lo/hi: and 100 byte bintobcd:
0017CB  1               ;
0017CB  1               ; Locals:
0017CB  1               
0017CB  1               dlength:
0017CB  1  00 00        	.byte	$0, $0
0017CD  1               ptr_save:
0017CD  1  00           	.byte	$0
0017CE  1  05           five:	.byte	$5		; counts the # of base 100 digits printed
0017CF  1  07           seven:	.byte	$7		; counts the # of sets of 10 digits printed
0017D0  1               
0017D0  1               print_mp:
0017D0  1  85 00        	sta	ptr		; store ptr lo from A
0017D2  1  84 01        	sty	ptr+1		; store ptr hi from Y
0017D4  1  98           	tya
0017D5  1  18           	clc
0017D6  1  6D D3 0B     	adc	arrayend+1	; add number of pages since we have to go
0017D9  1  8D CD 17     	sta	ptr_save	;   backwards for multiply
0017DC  1               
0017DC  1  AD D5 0B     	lda	declen+1	; converting to base 100, so dlength=dlength/2
0017DF  1  4A           	lsr
0017E0  1  8D CC 17     	sta	dlength+1
0017E3  1  AD D4 0B     	lda	declen
0017E6  1  6A           	ror
0017E7  1  8D CB 17     	sta	dlength
0017EA  1               
0017EA  1  A9 05        	lda	#5		; reset five and seven
0017EC  1  8D CE 17     	sta	five		; used for pretty output
0017EF  1  A9 07        	lda	#7
0017F1  1  8D CF 17     	sta	seven
0017F4  1               				; print left of decimal
0017F4  1  A0 00        	ldy	#0		; get first digit in array (big endian)
0017F6  1  B1 00        	lda	(ptr),y
0017F8  1  AA           	tax			; now convert from hex to dec
0017F9  1  BD 45 1B     	lda	bintobcd,x	; table lookup
0017FC  1  C9 0A        	cmp	#10		; if less than 10 skip leading zero
0017FE  1  90 06        	bcc	:+
001800  1  20 DA FD     	jsr	prbyte		; print it, only A gets hosed, safe to call
001803  1  4C 0C 18     	jmp	period
001806  1  18           :	clc			; no leading zero code
001807  1  69 B0        	adc	#$B0		;   convert single digit to ascii
001809  1  20 ED FD     	jsr	cout		;   print it
00180C  1  A9 AE        period:	lda	#'.'+$80	; print decimal point (fixed point math)
00180E  1  20 ED FD     	jsr	cout		;   print it
001811  1               
001811  1               print_mp1:			; loop through rest of decimal digits
001811  1  A0 00        	ldy	#0		; array[0] = 0
001813  1  A9 00        	lda	#0
001815  1  91 00        	sta	(ptr),y
001817  1  85 04        	sta	carry_mp	; clear multiprecision carry
001819  1               
001819  1  A5 00        	lda	ptr		; ptr_mp to get hosed, must be restored
00181B  1  85 02        	sta	ptr_mp
00181D  1  AD CD 17     	lda	ptr_save	; add number of pages since we have to go
001820  1  85 03        	sta	ptr_mp+1	;   backwards for multiply (right -> left)
001822  1               
001822  1               	; multi array x 100
001822  1               	; loop from LSB to MSB
001822  1               	; 16-bit product = array[i] * 100 + carry_mp;
001822  1               	; array[i] = product lo
001822  1               	; carry_mp = product hi
001822  1               	;
001822  1               	; C Algorithm:
001822  1               	;
001822  1               	;    while (j >= 0) {
001822  1                       ;	result.L = (long) number[j] * 100 + carry;
001822  1                       ;	number[j] = result.w.lo;
001822  1                       ;	carry = result.w.hi;
001822  1                       ;	j--;
001822  1                   	;    }
001822  1               
001822  1               	.macro	mult100
001822  1               	lda	(ptr_mp),y	; get it
001822  1               	tax
001822  1               	lda	mult100_lo,x	; get product lo
001822  1               	clc
001822  1               	adc	carry_mp	; add carry_mp to it
001822  1               	sta	(ptr_mp),y	;   and save it
001822  1               	lda	mult100_hi,x	; get product hi
001822  1               	adc	#0		;   add carry if present
001822  1               	sta	carry_mp	;   and save it
001822  1               	.endmacro
001822  1               
001822  1  AE D3 0B     	ldx	arrayend+1	; full pages
001825  1  86 0B        	stx	xreg
001827  1  AC D2 0B     	ldy	arrayend	; partial
00182A  1  98           	tya
00182B  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
00182D  1  F0 2D        	beq	@1		;   even (arrayend odd), so just need to
00182F  1  D0 05        	bne	@3		;   check for 2nd bit (odd or even # of pairs).
001831  1  C6 0B        :	dec	xreg
001833  1  C6 03        	dec	ptr_mp+1	; previous page of 256
001835  1  88           :	dey
001836  1  B1 02 AA BD  @3:	mult100
00183A  1  00 1C 18 65  
00183E  1  04 91 02 BD  
001842  1  00 1D 69 00  
001846  1  85 04        
001848  1  88           	dey
001849  1  B1 02 AA BD  @2:	mult100
00184D  1  00 1C 18 65  
001851  1  04 91 02 BD  
001855  1  00 1D 69 00  
001859  1  85 04        
00185B  1  88           	dey
00185C  1  B1 02 AA BD  @1:	mult100
001860  1  00 1C 18 65  
001864  1  04 91 02 BD  
001868  1  00 1D 69 00  
00186C  1  85 04        
00186E  1  88           	dey
00186F  1  B1 02 AA BD  @0:	mult100
001873  1  00 1C 18 65  
001877  1  04 91 02 BD  
00187B  1  00 1D 69 00  
00187F  1  85 04        
001881  1  98           	tya
001882  1  D0 B1        	bne	:-
001884  1  A6 0B        	ldx	xreg
001886  1  D0 A9        	bne	:--
001888  1               
001888  1               	; print array[0] (MSB)
001888  1  A0 00        	ldy	#0		; get first digit in array
00188A  1  B1 00        	lda	(ptr),y
00188C  1  AA           	tax			; now convert from hex to dec
00188D  1  BD 45 1B     	lda	bintobcd,x
001890  1  20 DA FD     	jsr	prbyte		; print it, only A gets hosed, safe to call
001893  1               
001893  1  CE CE 17     	dec	five		; five=five-1 for each base100 digit printed
001896  1  D0 1F        	bne	:+		; if five base100 digits printed
001898  1  A9 05        	lda	#5		;   then reset five count
00189A  1  8D CE 17     	sta	five		;   and print a space
00189D  1  A9 A0        	lda	#' '+$80
00189F  1  20 ED FD     	jsr	cout
0018A2  1  CE CF 17     	dec	seven		; seven=seven-1 for each set of 10 digits prted
0018A5  1  D0 10        	bne	:+		; if 7 sets of 10 printed
0018A7  1  A9 07        	lda	#7		;   then reset seven count
0018A9  1  8D CF 17     	sta	seven		;   and print a CR
0018AC  1  20 8E FD     	jsr	crout		;   then print 2 spaces
0018AF  1  A9 A0        	lda	#' '+$80
0018B1  1  20 ED FD     	jsr	cout
0018B4  1  20 ED FD     	jsr	cout
0018B7  1               :
0018B7  1               				; dlength = dlength - 1
0018B7  1  AD CB 17     	lda	dlength		; check if dlength = 0
0018BA  1  D0 03        	bne	:+		;   if so, it will roll to $FF
0018BC  1  CE CC 17     	dec	dlength+1	;     so dec dlength+1
0018BF  1  CE CB 17     :	dec	dlength		; dec dlength
0018C2  1  D0 06        	bne	:+		; check dlength and dlength+1 for zeros
0018C4  1  AD CC 17     	lda	dlength+1	;
0018C7  1  D0 01        	bne	:+
0018C9  1  60           	rts			; dlength = 0, all done
0018CA  1  4C 11 18     :	jmp	print_mp1	;
0018CD  1               
0018CD  1               
0018CD  1               ; Description: set array initial value
0018CD  1               ;
0018CD  1               ; Input:       Y(hi)/A(lo) pointer to mp
0018CD  1               ;              X = value left of decimal
0018CD  1               ;
0018CD  1               ; Output:      (ptr),0 = X
0018CD  1               ;              (ptr),1 - (ptr),length-1 = 0
0018CD  1               ;
0018CD  1               ; Clobbered:   A, X, Y
0018CD  1               ;
0018CD  1               ; Globals:     arraylen (16-bit), zp length (16-bit), zp ptr (16-bit)
0018CD  1               
0018CD  1               set_mp:
0018CD  1  85 00        	sta	ptr		; store ptr lo from A
0018CF  1  84 01        	sty	ptr+1		; store ptr hi from Y
0018D1  1  A0 00        	ldy	#0		; left of decimal
0018D3  1  8A           	txa
0018D4  1  91 00        	sta	(ptr),y		; store initial value
0018D6  1  E6 00        	inc	ptr		; bump up pointer
0018D8  1  D0 02        	bne	:+		;  to next digit
0018DA  1  E6 01        	inc	ptr+1		;  rest of array will be 0
0018DC  1  AE D3 0B     : 	ldx	arrayend+1	; full pages (hack, arrayend = arraylen - 1)
0018DF  1  AC D2 0B     	ldy	arrayend	; partial pages
0018E2  1  F0 18        	beq	@0		;   if not process full pages only
0018E4  1  E8           	inx			; bump up x +1 for the partial page
0018E5  1  18           	clc			; adjust to point below source start
0018E6  1  98           	tya			; - ex: ptr = $xx00, arraylen = 1
0018E7  1  65 00        	adc	ptr		; we want ptr = $(xx-1)01, y = $ff (255)
0018E9  1  85 00        	sta	ptr
0018EB  1  B0 02        	bcs	:+
0018ED  1  C6 01        	dec	ptr+1
0018EF  1  98           :	tya			; adjust y index value, y = -y
0018F0  1  49 FF        	eor	#$ff		; one's complement
0018F2  1  A8           	tay
0018F3  1  C8           	iny			; two's complement
0018F4  1  4A           	lsr			; lsr lsr will put 2nd bit in carry status
0018F5  1  4A           	lsr			; remember checking A here not Y
0018F6  1  A9 00        	lda	#0		; A must be set to #0 to clear array
0018F8  1               				; use carry to check for one/even pairs
0018F8  1               				; Duff's Device.   We know that arrayend is
0018F8  1  90 05        	bcc	@1		;   odd, so just need to check for 2nd bit
0018FA  1  B0 09        	bcs	@3		;   (odd or even # of pairs).
0018FC  1               				; NOTE: A = Y - 1, checking A, not Y
0018FC  1               				; if A & %10 = 0, then Y%3 = 1
0018FC  1               				; if A & %10 = 2, then Y%3 = 3
0018FC  1  91 00        @0:	sta	(ptr),y		; move even byte (0, 2, ..., 254)
0018FE  1  C8           	iny
0018FF  1  91 00        @1:	sta	(ptr),y		; move odd byte (1, 3, ..., 255)
001901  1  C8           	iny			; page done ?
001902  1  91 00        @2:	sta	(ptr),y		; move even byte (0, 2, ..., 254)
001904  1  C8           	iny
001905  1  91 00        @3:	sta	(ptr),y		; move odd byte (1, 3, ..., 255)
001907  1  C8           	iny			; page done ?
001908  1  D0 F2        	bne	@0		; b: no
00190A  1  E6 01        	inc	ptr+1		; next page
00190C  1  CA           	dex			; full page left ?
00190D  1  D0 ED        	bne	@0
00190F  1  60           	rts
001910  1               
001910  1               
001910  1               ; Description: Memory Allocation.  If you call malloc_pb it will move
001910  1               ;              heapptr up to start of next page and if allocation fails
001910  1               ;              it will not restore (yeah, it's a bug).  malloc will
001910  1               ;              allocate from the start of heapptr.  init_heap must be
001910  1               ;              called ONCE before any malloc calls.
001910  1               ;
001910  1               ; Input:       Y(hi)/A(lo) length of array
001910  1               ;
001910  1               ; Output:      Y(hi)/A(lo) pointer to array
001910  1               ;              CARRY=0: OK
001910  1               ;              CARRY=1: ERROR
001910  1               ;
001910  1               ; Clobbered:   A, X, Y, heapptr
001910  1               ;
001910  1               ; Allocation:  dynamic, returned by pointer
001910  1               ;
001910  1               malloc_pb:
001910  1  A6 0C        	ldx	heapptr		; check to see if already on page start
001912  1  F0 06        	beq	malloc		; on page? (lo = 0) move ahead with malloc
001914  1  A2 00        	ldx	#0		; not on page, zero out lo
001916  1  86 0C        	stx	heapptr		;
001918  1  E6 0D        	inc	heapptr+1	; bump up hi
00191A  1               malloc:
00191A  1  18           	clc
00191B  1  65 0C        	adc	heapptr		; add heapptr lo to a
00191D  1  AA           	tax			; save it in x
00191E  1  98           	tya			; copy y to a
00191F  1  65 0D        	adc	heapptr+1	; add heapptr hi to a
001921  1  A8           	tay			; save it in y
001922  1  C0 BF        	cpy	#>heapend	; cmp with heapend hi
001924  1  90 08        	bcc	:+		; is < heapend hi ok
001926  1  D0 0F        	bne	:++		; is > heapend hi not ok
001928  1  E0 FF        	cpx	#<heapend	; is = headend hi need to check lo
00192A  1  90 02        	bcc	:+		; is < heapend lo
00192C  1  D0 09        	bne	:++		; is > heapend lo
00192E  1  A5 0D        :	lda	heapptr+1	; get old heap hi in a
001930  1  84 0D        	sty	heapptr+1	; save new heapptr from y
001932  1  A8           	tay			; copy a to y to return
001933  1  A5 0C        	lda	heapptr		; load old head lo in a
001935  1  86 0C        	stx	heapptr		; update heapptr with new from x
001937  1  60           :	rts			; SEC set error
001938  1               
001938  1               
001938  1               ; Description: Convert string of ASCII to 16-bit hex.  Bug: no
001938  1               ;              overflow reported.  Keep strings to 5 digits.
001938  1               ;
001938  1               ; Input:       pointer to null terminated string in linebuf
001938  1               ;
001938  1               ; Output:      16-bit unsigned value in Y(hi)/A(lo)
001938  1               ;              CARRY=0: OK
001938  1               ;              CARRY=1: ERROR
001938  1               ;
001938  1               ; Clobbered:   A, Y, X
001938  1               ;
001938  1               ; Globals:     linebuf
001938  1               ;
001938  1               ; Locals:  hex (16-bit)
001938  1               
001938  1  00 00        hex:	.byte	$0, $0
00193A  1               
00193A  1               asciitohex:
00193A  1  A9 00        	lda	#0		; setup hex with with 0
00193C  1  8D 38 19     	sta	hex
00193F  1  8D 39 19     	sta	hex+1
001942  1  A2 00        	ldx	#0		; main loop
001944  1  F0 27        	beq	asciitohex2	; get first digit
001946  1               asciitohex1:
001946  1               	; hex = hex * 10
001946  1               	; hex = hex * (2 + 8)
001946  1  18           	clc
001947  1  0E 38 19     	asl	hex
00194A  1  2E 39 19     	rol	hex+1		; * 2
00194D  1  AD 38 19     	lda	hex		; save lo byte
001950  1  AC 39 19     	ldy	hex+1		; save hi byte
001953  1  0E 38 19     	asl	hex
001956  1  2E 39 19     	rol	hex+1		; * 4
001959  1  0E 38 19     	asl	hex
00195C  1  2E 39 19     	rol	hex+1		; * 8
00195F  1               	; add together hex * 2 (in a and y) to hex * 8
00195F  1               	; hex = hex * 2 + hex * 8
00195F  1  18           	clc
001960  1  6D 38 19     	adc	hex		; a + lo hex
001963  1  8D 38 19     	sta	hex		; store it
001966  1  98           	tya			; get hi hex
001967  1  6D 39 19     	adc	hex+1		; add with carry and
00196A  1  8D 39 19     	sta	hex+1		; store it
00196D  1               asciitohex2:
00196D  1  BD 00 02     	lda	linebuf,x	; get next ascii
001970  1  29 7F        	and	#$7F		; strip off 8th bit (Apple II issue)
001972  1  C9 3A        	cmp	#$3A		; ascii should be between $30-$39
001974  1  90 01        	bcc	:+		; if < $3A ok
001976  1  60           	rts			; else >= 40 and return with carry high
001977  1  C9 30        :	cmp	#$30		; if >= $30 ok
001979  1  B0 02        	bcs	:+		;
00197B  1  38           	sec			; use SEC for error flag
00197C  1  60           	rts			; return error
00197D  1  29 0F        :	and	#$0F		; mask off 4 high bits to get decimal number
00197F  1  18           	clc			; clear carry
001980  1  6D 38 19     	adc	hex		; add to hex lo
001983  1  8D 38 19     	sta	hex		; save it
001986  1  90 03        	bcc	:+		; no carry, no problem
001988  1  EE 39 19     	inc	hex+1		; got carry, inc hex hi
00198B  1  E8           :	inx			; inc x
00198C  1  BD 00 02     	lda	linebuf,x	; get next ascii
00198F  1  F0 02        	beq	:+		; got null/EOL exit out
001991  1  D0 B3        	bne	asciitohex1	; get next digit
001993  1               :
001993  1  AD 38 19     	lda	hex		; return results in a (lo) and y (hi)
001996  1  AC 39 19     	ldy	hex+1
001999  1  18           	clc			; clear carry to indicate no error
00199A  1  60           	rts
00199B  1               
00199B  1               
00199B  1               ; Description: Failed to allocation memory error and die
00199B  1               ;
00199B  1               ; Input:       Nada
00199B  1               ;
00199B  1               ; Output:      String to screen, then exit code
00199B  1               ;
00199B  1               ; Clobbered:   A, Y, X, ptr
00199B  1               ;
00199B  1               ; Globals:     zp ptr (16-bit)
00199B  1               
00199B  1               malloc_error:
00199B  1  20 8E FD     	jsr	crout		; print CR
00199E  1  A9 A7 A0 19  	sprint	"*** MEMORY ALLOCATION FAILED ***",$0D
0019A2  1  20 CC 19 F0  
0019A6  1  22 2A 2A 2A  
0019AA  1  20 4D 45 4D  
0019AE  1  4F 52 59 20  
0019B2  1  41 4C 4C 4F  
0019B6  1  43 41 54 49  
0019BA  1  4F 4E 20 46  
0019BE  1  41 49 4C 45  
0019C2  1  44 20 2A 2A  
0019C6  1  2A 0D 00     
0019C9  1  4C 69 FF     	jmp	warm
0019CC  1               
0019CC  1               
0019CC  1               ; Description: Print a string.
0019CC  1               ;
0019CC  1               ; Input:       Y(hi)/A(lo) pointer to string
0019CC  1               ;
0019CC  1               ; Output:      String to screen
0019CC  1               ;
0019CC  1               ; Clobbered:   A, Y, X, ptr
0019CC  1               ;
0019CC  1               ; Globals:     zp ptr (16-bit)
0019CC  1               
0019CC  1  85 00 84 01  print:	stay	ptr		; load Y/A (hi/lo) in ptr
0019D0  1  A0 00        	ldy	#0		; start with first char
0019D2  1  B1 00        	lda	(ptr),y		; load initial char
0019D4  1  09 80        :	ora	#$80		; we do not want flashing or inverse
0019D6  1               				;  (its an Apple II thing)
0019D6  1  29 DF        	and	#$DF		; convert to upper case
0019D8  1  20 ED FD     	jsr     cout		; call apple II char out
0019DB  1  C8           	iny			; y++
0019DC  1  B1 00        	lda	(ptr),y		; get next char
0019DE  1  D0 F4        	bne	:-		; not NULL? then print it
0019E0  1  60           	rts			; all done, move alone
0019E1  1               
0019E1  1               
0019E1  1               ; Description: Multiple 8-bit number by 10:  A = A * 10
0019E1  1               ;
0019E1  1               ; Input:       A (8-bit)
0019E1  1               ;
0019E1  1               ; Output:      A (8-bit)
0019E1  1               ;
0019E1  1               ; Clobbered:   A
0019E1  1               ;
0019E1  1               ; Locals:
0019E1  1               
0019E1  1  00           x10tmp:	.byte	$0
0019E2  1               
0019E2  1               x10:
0019E2  1  0A           	asl			; 2 x
0019E3  1  8D E1 19     	sta	x10tmp		; save it
0019E6  1  0A           	asl			; 4 x
0019E7  1  0A           	asl			; 8 x
0019E8  1  18           	clc
0019E9  1  6D E1 19     	adc	x10tmp		; 8 x + 2 x
0019EC  1  60           	rts
0019ED  1               
0019ED  1               
0019ED  1               ; Description: Detect Thunderclock card
0019ED  1               ;
0019ED  1               ; Output:      X = slot of card, else 0
0019ED  1               ;
0019ED  1               ; Clobbered:   A, X, Y
0019ED  1               
0019ED  1               detect_thunderclock:
0019ED  1  A2 08        	ldx	#8		; start at slot 7
0019EF  1  CA           :	dex			; count down the slots
0019F0  1  F0 32        	beq	:+		;   got to zero?  then no card, return
0019F2  1  8A           	txa			; setup pointer at $CN08
0019F3  1  09 C0        	ora	#$C0
0019F5  1  85 01        	sta	ptr+1
0019F7  1  A9 08        	lda	#$08
0019F9  1  85 00        	sta	ptr
0019FB  1  A0 00        	ldy	#0		; check for 38 B0 01
0019FD  1  B1 00        	lda	(ptr),y
0019FF  1  C9 38        	cmp	#$38
001A01  1  D0 EC        	bne	:-		; This isn't the card you are looking for.
001A03  1  C8           	iny
001A04  1  B1 00        	lda	(ptr),y
001A06  1  C9 B0        	cmp	#$B0
001A08  1  D0 E5        	bne	:-		; This isn't the card you are looking for.
001A0A  1  C8           	iny
001A0B  1  B1 00        	lda	(ptr),y
001A0D  1  C9 01        	cmp	#$01
001A0F  1  D0 DE        	bne	:-		; This isn't the card you are looking for.
001A11  1  8A           	txa			; Found it!
001A12  1               				;   This IS the card you are looking for.
001A12  1  09 C0        	ora	#$C0		; write out location of card
001A14  1  8D 62 1A     	sta	rdtcp+2		;   This is self-mod code,
001A17  1  8D 5F 1A     	sta	wdtcp+2		;   generally, not a great idea.
001A1A  1  A9 08        	lda	#$08		;   wdtcp/rdtcp to be used later
001A1C  1  8D 61 1A     	sta	rdtcp+1
001A1F  1  A9 0B        	lda	#$0B
001A21  1  8D 5E 1A     	sta	wdtcp+1
001A24  1  60           :	rts			; if x > 0, found it
001A25  1               
001A25  1               
001A25  1               ; Description: Detect "No Slot Clock".  This is very hackish and can return
001A25  1               ;              a false positive (just try it on the IIgs).  I could not find
001A25  1               ;              any docs on how to detect the clock, other than to try to read
001A25  1               ;              it.  The read code is a disassembly of the clockread DOS
001A25  1               ;              utility.  To validate success the day of week must be 1, 2, 3,
001A25  1               ;              4, 5, 6, or 7.  Week/weak check (ha! that was awesome :-).
001A25  1               ;              I should probably check for proper ranges for all values to
001A25  1               ;              reduce the risk of a false positive.
001A25  1               ;
001A25  1               ; Output:      CARRY set = success or false positive
001A25  1               ;              CARRY cleared (0) = no no slot clock found
001A25  1               ;
001A25  1               ; Clobbered:   A, X, Y
001A25  1               ;
001A25  1               ; Globals:     nsc_dy
001A25  1               
001A25  1               detect_noslotclock:
001A25  1  20 00 1E     	jsr	read_noslotclock
001A28  1  18           	clc			; assume no clock
001A29  1  AD 06 1E     	lda	nsc_dy		; load day of week
001A2C  1  F0 01        	beq	:+		; must be 1 - 7
001A2E  1  38           	sec			; set carry if clock
001A2F  1  60           :	rts
001A30  1               
001A30  1               
001A30  1               ; Description: If there is a clock, then load the time into (ptr)
001A30  1               ;
001A30  1               ; Input:       Y(hi)/A(lo) 16-bit pointer to 4-byte array
001A30  1               ;              gotclock = 0, no clock, otherwise it is the type of clock:
001A30  1               ;                1 = thunderclock
001A30  1               ;                2 = no slot clock
001A30  1               ;
001A30  1               ; Output:      4-byte array  = s,m,h,1/100s (1/100 if supported by clock)
001A30  1               ;
001A30  1               ; Clobbered:   A, X, Y
001A30  1               ;
001A30  1               ; Globals:     ptr(16-bit), gotclock(8-bit, read-only), nsc_s(8-bit),
001A30  1               ;              nsc_m(8-bit), nsc_h(8-bit), nsc_ss(8-bit)
001A30  1               ;
001A30  1               ; Calls:       read_noslotclock
001A30  1               
001A30  1               gettime:
001A30  1  85 00        	sta	ptr
001A32  1  84 01        	sty	ptr+1
001A34  1               
001A34  1  AD C6 0B     	lda	gotclock
001A37  1  D0 01        	bne	:+
001A39  1  60           	rts
001A3A  1  C9 01        :	cmp	#1		; no slot clock
001A3C  1  D0 1D        	bne	thunder
001A3E  1  20 00 1E     	jsr	read_noslotclock
001A41  1  A0 00        	ldy	#0
001A43  1  AD 09 1E     	lda	nsc_s
001A46  1  91 00        	sta	(ptr),y
001A48  1  C8           	iny
001A49  1  AD 08 1E     	lda	nsc_m
001A4C  1  91 00        	sta	(ptr),y
001A4E  1  C8           	iny
001A4F  1  AD 07 1E     	lda	nsc_h
001A52  1  91 00        	sta	(ptr),y
001A54  1  C8           	iny
001A55  1  AD 0A 1E     	lda	nsc_ss
001A58  1  91 00        	sta	(ptr),y
001A5A  1  60           	rts
001A5B  1               thunder:			; must be thunderclock
001A5B  1  A9 A3        	lda	#$A3
001A5D  1  20 5D 1A     wdtcp:	jsr	wdtcp		; self mod code, set read format
001A60  1  20 60 1A     rdtcp:	jsr	rdtcp		; self mod code, read time into linebuf
001A63  1               				; parse out the thunderclock output from
001A63  1  A0 00        	ldy	#0		;   linebuf, y holds the number of pairs to
001A65  1  A2 11        	ldx	#17		;   get (SS,MM,HH)
001A67  1  CA           :	dex
001A68  1  BD 00 02     	lda	linebuf,x	; get 1's place
001A6B  1  49 B0        	eor	#$B0		; ASCII to decimal
001A6D  1  91 00        	sta	(ptr),y		; store it
001A6F  1  CA           	dex
001A70  1  BD 00 02     	lda	linebuf,x	; get 10's place
001A73  1  49 B0        	eor	#$B0		; ASCII to decimal
001A75  1  20 E2 19     	jsr	x10		; a = a * 10
001A78  1  18           	clc
001A79  1  71 00        	adc	(ptr),y		; add to 1's
001A7B  1  91 00        	sta	(ptr),y		; store number (range 0-99)
001A7D  1  CA           	dex			; skip comma
001A7E  1  C8           	iny			; next pair
001A7F  1  C0 03        	cpy	#3		; got 3rd pair?
001A81  1  D0 E4        	bne	:-		;   no, then get next pair
001A83  1  A9 00        	lda	#0		; There is no 1/100 with thunderclock so set
001A85  1  91 00        	sta	(ptr),y		;   1/100 to 0
001A87  1  60           	rts
001A88  1               
001A88  1               
001A88  1               ; Description: If there is a clock, then print the time
001A88  1               ;
001A88  1               ; Input:       Y(hi)/A(lo) 16-bit pointer to 4-byte array
001A88  1               ;
001A88  1               ; Output:      Time (hh:mm:ss): hh:mm:ss[.1/100s] to screen
001A88  1               ;
001A88  1               ; Clobbered:   A, X, Y
001A88  1               ;
001A88  1               ; Globals:     starttime(32-bit), endtime(32-bit)
001A88  1               
001A88  1               printtime:
001A88  1  AE C6 0B     	ldx	gotclock	; check for clock type
001A8B  1  D0 01        	bne	:+		;   if zero
001A8D  1  60           	rts			;     then return
001A8E  1  20 8E FD     :	jsr	crout
001A91  1  A9 9A A0 1A  	sprint	"Time (hh:mm:ss): "
001A95  1  20 CC 19 F0  
001A99  1  12 54 69 6D  
001A9D  1  65 20 28 68  
001AA1  1  68 3A 6D 6D  
001AA5  1  3A 73 73 29  
001AA9  1  3A 20 00     
001AAC  1  38           	sec			; set carry
001AAD  1  AD CF 0B     	lda	endtime+3	; sub starttime 1/100 sec from endtime
001AB0  1  ED CB 0B     	sbc	starttime+3	;   1/100 sec
001AB3  1  B0 05        	bcs	:+		; carry still set?  Positive, no prob
001AB5  1  20 23 1B     	jsr	decsec		; dec a sec
001AB8  1  69 64        	adc	#100		; got neg?  add 100
001ABA  1  8D CB 0B     :	sta	starttime+3	; save it for printing
001ABD  1  38           	sec			; set carry
001ABE  1  AD CC 0B     	lda	endtime+0	; sub starttime sec from endtime sec
001AC1  1  ED C8 0B     	sbc	starttime+0
001AC4  1  B0 05        	bcs	:+		; carry still set?  Positive, no prob
001AC6  1  20 34 1B     	jsr	decmin		; dec a min
001AC9  1  69 3C        	adc	#60		; got neg?  add 60
001ACB  1  8D C8 0B     :	sta	starttime+0	; save it for printing
001ACE  1  38           	sec			; set carry
001ACF  1  AD CD 0B     	lda	endtime+1	; sub starttime min from endtime min
001AD2  1  ED C9 0B     	sbc	starttime+1
001AD5  1  B0 05        	bcs	:+		; carry still set?  Positive, no prob
001AD7  1  CE CE 0B     	dec	endtime+2	; dec an hour
001ADA  1  69 3C        	adc	#60		; got neg?  add 60
001ADC  1  8D C9 0B     :	sta	starttime+1	; save it for printing
001ADF  1  38           	sec			; set carry
001AE0  1  AD CE 0B     	lda	endtime+2	; sub starttime hr from endtime hr
001AE3  1  ED CA 0B     	sbc	starttime+2
001AE6  1  B0 02        	bcs	:+		; carry still set?  Positive, no prob
001AE8  1  69 18        	adc	#24		; got neg?  add 60
001AEA  1  AA           :	tax			; print hours
001AEB  1  BD 45 1B     	lda	bintobcd,x
001AEE  1  20 DA FD     	jsr	prbyte
001AF1  1  A9 BA        	lda	#':'+$80
001AF3  1  20 ED FD     	jsr	cout
001AF6  1  AE C9 0B     	ldx	starttime+1	; print minutes
001AF9  1  BD 45 1B     	lda	bintobcd,x
001AFC  1  20 DA FD     	jsr	prbyte
001AFF  1  A9 BA        	lda	#':'+$80
001B01  1  20 ED FD     	jsr	cout
001B04  1  AE C8 0B     	ldx	starttime	; print seconds
001B07  1  BD 45 1B     	lda	bintobcd,x
001B0A  1  20 DA FD     	jsr	prbyte
001B0D  1  AE CB 0B     	ldx	starttime+3
001B10  1  F0 0E        	beq	:+
001B12  1  A9 AE        	lda	#'.'+$80
001B14  1  20 ED FD     	jsr	cout
001B17  1  AE CB 0B     	ldx	starttime+3	; print 1/100 seconds
001B1A  1  BD 45 1B     	lda	bintobcd,x
001B1D  1  20 DA FD     	jsr	prbyte
001B20  1  4C 8E FD     :	jmp	crout		; crout will have rts
001B23  1               
001B23  1  AE CC 0B     decsec:	ldx	endtime		; load endtime seconds
001B26  1  D0 08        	bne	:+		; not zero, then just dec it
001B28  1  20 34 1B     	jsr	decmin		; got zero, so take a min
001B2B  1  A2 3C        	ldx	#60		;   and set sec to 60
001B2D  1  8E CC 0B     	stx	endtime
001B30  1  CE CC 0B     :	dec	endtime
001B33  1  60           	rts
001B34  1               
001B34  1  AE CD 0B     decmin:	ldx	endtime+1	; load endtime minites
001B37  1  D0 08        	bne	:+		; not zero, then just dec it
001B39  1  CE CE 0B     	dec	endtime+2	; got zero, so take an hour
001B3C  1  A2 3C        	ldx	#60		;   and set min to 60
001B3E  1  8E CD 0B     	stx	endtime+1
001B41  1  CE CD 0B     :	dec	endtime+1
001B44  1  60           	rts
001B45  1               
001B45  1               
001B45  1               ; Description: BIN/HEX to BCD table.  Used by print_mp and printtime
001B45  1               
001B45  1               bintobcd:
001B45  1  00 01 02 03  	.byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09
001B49  1  04 05 06 07  
001B4D  1  08 09        
001B4F  1  10 11 12 13  	.byte	$10,$11,$12,$13,$14,$15,$16,$17,$18,$19
001B53  1  14 15 16 17  
001B57  1  18 19        
001B59  1  20 21 22 23  	.byte	$20,$21,$22,$23,$24,$25,$26,$27,$28,$29
001B5D  1  24 25 26 27  
001B61  1  28 29        
001B63  1  30 31 32 33  	.byte	$30,$31,$32,$33,$34,$35,$36,$37,$38,$39
001B67  1  34 35 36 37  
001B6B  1  38 39        
001B6D  1  40 41 42 43  	.byte	$40,$41,$42,$43,$44,$45,$46,$47,$48,$49
001B71  1  44 45 46 47  
001B75  1  48 49        
001B77  1  50 51 52 53  	.byte	$50,$51,$52,$53,$54,$55,$56,$57,$58,$59
001B7B  1  54 55 56 57  
001B7F  1  58 59        
001B81  1  60 61 62 63  	.byte	$60,$61,$62,$63,$64,$65,$66,$67,$68,$69
001B85  1  64 65 66 67  
001B89  1  68 69        
001B8B  1  70 71 72 73  	.byte	$70,$71,$72,$73,$74,$75,$76,$77,$78,$79
001B8F  1  74 75 76 77  
001B93  1  78 79        
001B95  1  80 81 82 83  	.byte	$80,$81,$82,$83,$84,$85,$86,$87,$88,$89
001B99  1  84 85 86 87  
001B9D  1  88 89        
001B9F  1  90 91 92 93  	.byte	$90,$91,$92,$93,$94,$95,$96,$97,$98,$99
001BA3  1  94 95 96 97  
001BA7  1  98 99        
001BA9  1               
001BA9  1               
001BA9  1               ; Description: 16-bit table of 0-255 * 100 broken down into multi100_lo and
001BA9  1               ;              multi100_hi.  Used by print_mp
001BA9  1               
001BA9  1               	.linecont +
001BA9  1               	.define	timestable \
001BA9  1               		00000,00100,00200,00300,00400,00500,00600,00700,\
001BA9  1               		00800,00900,01000,01100,01200,01300,01400,01500,\
001BA9  1               		01600,01700,01800,01900,02000,02100,02200,02300,\
001BA9  1               		02400,02500,02600,02700,02800,02900,03000,03100,\
001BA9  1               		03200,03300,03400,03500,03600,03700,03800,03900,\
001BA9  1               		04000,04100,04200,04300,04400,04500,04600,04700,\
001BA9  1               		04800,04900,05000,05100,05200,05300,05400,05500,\
001BA9  1               		05600,05700,05800,05900,06000,06100,06200,06300,\
001BA9  1               		06400,06500,06600,06700,06800,06900,07000,07100,\
001BA9  1               		07200,07300,07400,07500,07600,07700,07800,07900,\
001BA9  1               		08000,08100,08200,08300,08400,08500,08600,08700,\
001BA9  1               		08800,08900,09000,09100,09200,09300,09400,09500,\
001BA9  1               		09600,09700,09800,09900,10000,10100,10200,10300,\
001BA9  1               		10400,10500,10600,10700,10800,10900,11000,11100,\
001BA9  1               		11200,11300,11400,11500,11600,11700,11800,11900,\
001BA9  1               		12000,12100,12200,12300,12400,12500,12600,12700,\
001BA9  1               		12800,12900,13000,13100,13200,13300,13400,13500,\
001BA9  1               		13600,13700,13800,13900,14000,14100,14200,14300,\
001BA9  1               		14400,14500,14600,14700,14800,14900,15000,15100,\
001BA9  1               		15200,15300,15400,15500,15600,15700,15800,15900,\
001BA9  1               		16000,16100,16200,16300,16400,16500,16600,16700,\
001BA9  1               		16800,16900,17000,17100,17200,17300,17400,17500,\
001BA9  1               		17600,17700,17800,17900,18000,18100,18200,18300,\
001BA9  1               		18400,18500,18600,18700,18800,18900,19000,19100,\
001BA9  1               		19200,19300,19400,19500,19600,19700,19800,19900,\
001BA9  1               		20000,20100,20200,20300,20400,20500,20600,20700,\
001BA9  1               		20800,20900,21000,21100,21200,21300,21400,21500,\
001BA9  1               		21600,21700,21800,21900,22000,22100,22200,22300,\
001BA9  1               		22400,22500,22600,22700,22800,22900,23000,23100,\
001BA9  1               		23200,23300,23400,23500,23600,23700,23800,23900,\
001BA9  1               		24000,24100,24200,24300,24400,24500,24600,24700,\
001BA9  1               		24800,24900,25000,25100,25200,25300,25400,25500
001BA9  1               
001BA9  1  xx xx xx xx  	.align	256		; speed bump (~.35 sec for 1000 digits)
001BAD  1  xx xx xx xx  
001BB1  1  xx xx xx xx  
001BB5  1  xx xx xx xx  
001BB9  1  xx xx xx xx  
001BBD  1  xx xx xx xx  
001BC1  1  xx xx xx xx  
001BC5  1  xx xx xx xx  
001BC9  1  xx xx xx xx  
001BCD  1  xx xx xx xx  
001BD1  1  xx xx xx xx  
001BD5  1  xx xx xx xx  
001BD9  1  xx xx xx xx  
001BDD  1  xx xx xx xx  
001BE1  1  xx xx xx xx  
001BE5  1  xx xx xx xx  
001BE9  1  xx xx xx xx  
001BED  1  xx xx xx xx  
001BF1  1  xx xx xx xx  
001BF5  1  xx xx xx xx  
001BF9  1  xx xx xx xx  
001BFD  1  xx xx xx     
001C00  1               				; read_noslotclock has to be aligned anyway
001C00  1               				; so extra bytes in obj code already there
001C00  1               mult100_lo:
001C00  1  00 64 C8 2C  	.lobytes timestable
001C04  1  90 F4 58 BC  
001C08  1  20 84 E8 4C  
001C0C  1  B0 14 78 DC  
001C10  1  40 A4 08 6C  
001C14  1  D0 34 98 FC  
001C18  1  60 C4 28 8C  
001C1C  1  F0 54 B8 1C  
001C20  1  80 E4 48 AC  
001C24  1  10 74 D8 3C  
001C28  1  A0 04 68 CC  
001C2C  1  30 94 F8 5C  
001C30  1  C0 24 88 EC  
001C34  1  50 B4 18 7C  
001C38  1  E0 44 A8 0C  
001C3C  1  70 D4 38 9C  
001C40  1  00 64 C8 2C  
001C44  1  90 F4 58 BC  
001C48  1  20 84 E8 4C  
001C4C  1  B0 14 78 DC  
001C50  1  40 A4 08 6C  
001C54  1  D0 34 98 FC  
001C58  1  60 C4 28 8C  
001C5C  1  F0 54 B8 1C  
001C60  1  80 E4 48 AC  
001D00  1               mult100_hi:
001D00  1  00 00 00 01  	.hibytes timestable
001D04  1  01 01 02 02  
001D08  1  03 03 03 04  
001D0C  1  04 05 05 05  
001D10  1  06 06 07 07  
001D14  1  07 08 08 08  
001D18  1  09 09 0A 0A  
001D1C  1  0A 0B 0B 0C  
001D20  1  0C 0C 0D 0D  
001D24  1  0E 0E 0E 0F  
001D28  1  0F 10 10 10  
001D2C  1  11 11 11 12  
001D30  1  12 13 13 13  
001D34  1  14 14 15 15  
001D38  1  15 16 16 17  
001D3C  1  17 17 18 18  
001D40  1  19 19 19 1A  
001D44  1  1A 1A 1B 1B  
001D48  1  1C 1C 1C 1D  
001D4C  1  1D 1E 1E 1E  
001D50  1  1F 1F 20 20  
001D54  1  20 21 21 21  
001D58  1  22 22 23 23  
001D5C  1  23 24 24 25  
001D60  1  25 25 26 26  
001E00  1               
001E00  1               
001E00  1               ; Description: Cleaned up disassembly of the No Slot Clock DOS clockread
001E00  1               ;              utility.  This code MUST be page aligned.
001E00  1               ;
001E00  1               ; Output:      nsc_* updated
001E00  1               ;
001E00  1               ; Clobbered:   A, X, Y
001E00  1               ;
001E00  1               ; Locals:
001E00  1               
001E00  1               dosptr	=	$43
001E00  1               	.align	256		; must be aligned to page
001E00  1               read_noslotclock:
001E00  1  38           	sec
001E01  1  B0 10        	bcs     :+
001E03  1  57           nsc_yr:	.byte	$57		; binary year
001E04  1  04           nsc_mo:	.byte	$04		; binary month
001E05  1  08           nsc_dt:	.byte	$08		; binary day of month
001E06  1  04           nsc_dy:	.byte	$04		; binary day of week
001E07  1  0E           nsc_h:	.byte	$0E		; binary hour
001E08  1  2C           nsc_m:	.byte	$2C		; binary minute
001E09  1  00           nsc_s:	.byte	$00		; binary second
001E0A  1  00           nsc_ss:	.byte	$00		; binary 1/100th of second
001E0B  1  5C A3 3A C5  	.byte	$5C,$A3,$3A,$C5,$5C,$A3,$3A,$C5
001E0F  1  5C A3 3A C5  
001E13  1  78           :	sei
001E14  1  AD FF CF     	lda     $CFFF
001E17  1  48           	pha
001E18  1  8D 00 C3     	sta     $C300
001E1B  1  AD 04 C8     	lda     $C804
001E1E  1  A2 0A        	ldx     #$0A
001E20  1  B5 41        :	lda     $41,x
001E22  1  48           	pha
001E23  1  CA           	dex
001E24  1  D0 FA        	bne     :-
001E26  1  A9 0B        	lda     #$0B
001E28  1  85 42        	sta     $42
001E2A  1  A9 60        	lda     #$60
001E2C  1  85 43        	sta     dosptr
001E2E  1  20 43 00     	jsr     dosptr
001E31  1  BA           	tsx
001E32  1  BD 00 01     	lda     $0100,x
001E35  1  85 43        	sta     dosptr
001E37  1  A0 07        	ldy     #$07
001E39  1  B1 42        :	lda     ($42),y
001E3B  1  38           	sec
001E3C  1  6A           	ror     a
001E3D  1  48           :	pha
001E3E  1  A9 00        	lda     #$00
001E40  1  2A           	rol     a
001E41  1  AA           	tax
001E42  1  BD 00 C8     	lda     $C800,x
001E45  1  68           	pla
001E46  1  4A           	lsr     a
001E47  1  D0 F4        	bne     :-
001E49  1  88           	dey
001E4A  1  10 ED        	bpl     :--
001E4C  1  A2 07        	ldx     #$07
001E4E  1  A0 07        :	ldy     #$07
001E50  1  AD 04 C8     :	lda     $C804
001E53  1  6A           	ror     a
001E54  1  76 44        	ror     $44,x
001E56  1  88           	dey
001E57  1  10 F7        	bpl     :-
001E59  1  B5 44        	lda     $44,x
001E5B  1  48           	pha
001E5C  1  29 0F        	and     #$0F
001E5E  1  95 44        	sta     $44,x
001E60  1  68           	pla
001E61  1  29 F0        	and     #$F0
001E63  1  4A           	lsr     a
001E64  1  4A           	lsr     a
001E65  1  4A           	lsr     a
001E66  1  4A           	lsr     a
001E67  1  A8           	tay
001E68  1  F0 07        	beq     :++
001E6A  1  A9 00        	lda     #$00
001E6C  1  69 0A        :	adc     #$0A
001E6E  1  88           	dey
001E6F  1  D0 FB        	bne     :-
001E71  1  75 44        :	adc     $44,x
001E73  1  95 44        	sta     $44,x
001E75  1  CA           	dex
001E76  1  10 D6        	bpl     :----
001E78  1  A9 03        	lda     #$03
001E7A  1  85 42        	sta     $42
001E7C  1  A0 07        	ldy     #$07
001E7E  1  B9 44 00     :	lda     $44,y
001E81  1  91 42        	sta     ($42),y
001E83  1  88           	dey
001E84  1  10 F8        	bpl     :-
001E86  1  A2 00        	ldx     #$00
001E88  1  68           :	pla
001E89  1  95 42        	sta     $42,x
001E8B  1  E8           	inx
001E8C  1  8A           	txa
001E8D  1  C9 0A        	cmp     #$0A
001E8F  1  D0 F7        	bne     :-
001E91  1  68           	pla
001E92  1  2A           	rol     a
001E93  1  B0 03        	bcs     :+
001E95  1  8D FF CF     	sta     $CFFF
001E98  1  60           :	rts
001E99  1               
001E99  1               
001E99  1               ;; end of subs start of heap
001E99  1               
001E99  1               end:
001E99  1               heap:				; start of dynamic memory
001E99  1               
