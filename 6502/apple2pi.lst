ca65 V2.13.2 - (C) Copyright 1998-2005 Ullrich von Bassewitz
Main file   : apple2pi.s
Current file: apple2pi.s

000000r 1               ;; Apple Pie
000000r 1               ;;
000000r 1               ;; Egan Ford (egan@sense.net) with a lot of optimizations and pointers from
000000r 1               ;; Anton Treuenfels (atreuenfels@earthlink.net)
000000r 1               ;;
000000r 1               ;; Sept, 8 2012
000000r 1               ;;
000000r 1               ;; Apple Pie (Pi and e) will compute up to 10,000 decimal digits of Pi or e.
000000r 1               ;; All Apple Pie computation is base 256 and then converted to base 10 for
000000r 1               ;; display (technically base 100, but they both display the same).  Arrays
000000r 1               ;; of bytes are used to represent multiprecision numbers.  In the comments
000000r 1               ;; below "array" refers to a big endian multiprecision number.
000000r 1               ;;
000000r 1               ;; Aug, 8 2012
000000r 1               ;;
000000r 1               ;; Increased range to 22950
000000r 1               ;;
000000r 1               
000000r 1               
000000r 1               ;; replace Clobbered: with Registers:
000000r 1               
000000r 1               
000000r 1               ;; Apple II variables/vectors
000000r 1               
000000r 1               getln1	=	$FD6F		; get line of input and store in $200
000000r 1               cout	=	$FDED		; character out sub
000000r 1               prbyte	=	$FDDA		; print a hex byte
000000r 1               crout	=	$FD8E		; CR out sub
000000r 1               rdkey	=	$FD0C		; read key
000000r 1               warm	=	$FF69		; back to monitor
000000r 1               linebuf	=	$200		; input line buffer
000000r 1               promptc	=	$33		; location of getln1 prompt char
000000r 1               
000000r 1               
000000r 1               ;; my variables/vectors
000000r 1               
000000r 1               ptr	=	$0		; $0-$1 16 bit generic pointer
000000r 1               ptr_mp	=	$2		; $2-$3 16 bit generic pointer
000000r 1               a32	=	$4		; $4-$7 32 bit number
000000r 1               carry_mp=	$4		; $4-$4  8 bit multiprecision carry
000000r 1               				;          32/16 div
000000r 1               dividend=	$4		; $4-$7 32 bit
000000r 1               remainder=	$4		; $4-$5 16 bit
000000r 1               quotient=	$6		; $6-$7 16 bit
000000r 1               divisor	=	$8		; $8-$9 16 bit
000000r 1               				;          backup regs
000000r 1               yreg	=	$A		; $A-$A  8 bit
000000r 1               xreg	=	$B		; $B-$B  8 bit
000000r 1               heapptr	=	$C		; $C-$D 16 bit start of free memory
000000r 1               
000000r 1               org	=	$800		; start here
000000r 1               heapend	=	$BFFF		; end of usable memory
000000r 1               max	=	22950		; max number of digits (FYI, 9860 = 4K)
000000r 1               				; 22950 is max because n = n + 2 in atan will get > 32767
000000r 1               				; and div16 bug when divisor 16th bit high.  Need to fix.
000000r 1               min	=	100		; min number of digits
000000r 1               
000000r 1               
000000r 1               
000000r 1               ;; start of global macros
000000r 1               
000000r 1               .include	"pimacros.m"
000000r 2               .macro	cnton num
000000r 2               	sta	$E100+num
000000r 2               .endmacro
000000r 2               
000000r 2               .macro	cntoff num
000000r 2               	sta	$E200+num
000000r 2               .endmacro
000000r 2               
000000r 2               .macro	chkpt num
000000r 2               	sta	$E300+num
000000r 2               .endmacro
000000r 2               
000000r 2               ; Description:	Load A/Y registers with a 16-bit value,
000000r 2               ;               low byte in A, high byte in Y
000000r 2               ; Input:        value (16-bit) immediate, absolute and zero-page addressing
000000r 2               
000000r 2               .macro	lday	value
000000r 2               	.if (.match (.left (1, {value}), #))
000000r 2               		lda	#<(.right (.tcount ({value})-1, {value}))
000000r 2               		ldy	#>(.right (.tcount ({value})-1, {value}))
000000r 2               	.else
000000r 2               		lda	value
000000r 2               		ldy	value+1
000000r 2               	.endif
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:  Store 16-bit value in A/Y registers to memory,
000000r 2               ;               low byte in A, high byte in Y
000000r 2               ; Input:        value (16-bit), absolute and zero-page addressing
000000r 2               
000000r 2               .macro	stay	location
000000r 2               	sta	location
000000r 2               	sty	location+1
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Allocate an array of size "sizeof" at "ptr"
000000r 2               ; Input:	ptr (16-bit), sizeof (16-bit)
000000r 2               ;		ptr = pointer to start of memory (if successful)
000000r 2               ;		sizeof = length of requested memory, length can be
000000r 2               ;		immediate (e.g. #1000) or absolute/zp (label)
000000r 2               ; Calls:	malloc, if malloc fails then calls malloc_error and dies
000000r 2               ;		program.
000000r 2               
000000r 2               .macro	alloc	ptr, sizeof
000000r 2               	lday	sizeof
000000r 2               	jsr	malloc		; call malloc
000000r 2               	bcc	:+		; if not failure (bcc) set ptr lo/hi
000000r 2               	jmp	malloc_error	; on failure jmp to malloc_error and die
000000r 2               :	stay	ptr
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Set initial value left of decimal of "ptr_a" array to
000000r 2               ;		"value", i.e. (ptr_a),0 = value
000000r 2               ; Input:	ptr_a (16-bit), value (8-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		value = integer to be set left of decimal point
000000r 2               ; Calls:	set_mp
000000r 2               
000000r 2               .macro	mset	ptr_a, value	; a = value
000000r 2               cnton 19
000000r 2               	lday	ptr_a
000000r 2               	ldx	value
000000r 2               	jsr	set_mp		; set it
000000r 2               cntoff 19
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Transfer array (ptr_b)[0,sizeof(ptr_b)] to ptr_a (a = b)
000000r 2               ; Input:	ptr_a (16-bit), ptr_b (16-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		ptr_b = pointer to start of allocated array
000000r 2               ; Calls:	copy_mp
000000r 2               
000000r 2               .macro	mcopy	ptr_a, ptr_b	; a = b
000000r 2               cnton 20
000000r 2               	lday	ptr_a
000000r 2               	stay	ptr_mp
000000r 2               	lday	ptr_b
000000r 2               	jsr	copy_mp		; copy it
000000r 2               cntoff 20
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Left shift array ptr_a
000000r 2               ; Input:	ptr_a (16-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ; Calls:	asl_mp
000000r 2               
000000r 2               .macro	masl	ptr_a		; a = a * 2
000000r 2               cnton 21
000000r 2               	lday	ptr_a
000000r 2               	jsr	asl_mp		; left shift it
000000r 2               cntoff 21
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Add array ptr_b to array ptr_a (a = a + b)
000000r 2               ; Input:	ptr_a (16-bit), ptr_b (16-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		ptr_b = pointer to start of allocated array
000000r 2               ; Calls:	add_mp
000000r 2               
000000r 2               .macro	madd	ptr_a, ptr_b	; a = a + b
000000r 2               cnton 22
000000r 2               	lday	ptr_b
000000r 2               	stay	ptr_mp
000000r 2               	lday	ptr_a
000000r 2               	jsr	add_mp		; add it
000000r 2               cntoff 22
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Subtract array ptr_b from array ptr_a (a = a - b)
000000r 2               ; Input:	ptr_a (16-bit), ptr_b (16-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		ptr_b = pointer to start of allocated array
000000r 2               ; Calls:	sub_mp
000000r 2               
000000r 2               .macro	msub	ptr_a, ptr_b	; a = a - b
000000r 2               cnton 23
000000r 2               	lday	ptr_b
000000r 2               	stay	ptr_mp
000000r 2               	lday	ptr_a
000000r 2               	jsr	sub_mp		; sub it
000000r 2               cntoff 23
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Divide ptr_a by an 8-bit quantity (a = a / divisor)
000000r 2               ; Input:	ptr_a (16-bit), divisor (8-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		divisor = 8-bit immediate or absolute/zp integer
000000r 2               ; Calls:	div_mp
000000r 2               ; Return:	If ptr_a = 0 (array of zeros), then carry is set,
000000r 2               ;		otherwise carry is clear.
000000r 2               
000000r 2               .macro	mdiv	ptr_a, divisor	; a = a / divisor (8-bit)
000000r 2               cnton 24
000000r 2               	lday	ptr_a
000000r 2               	ldx	divisor
000000r 2               	jsr	div_mp		; div it
000000r 2               cntoff 24
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Divide ptr_a by a 16-bit quantity (a = a / value)
000000r 2               ; Input:	ptr_a (16-bit), value (8-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		value = 16-bit immediate or absolute/zp integer
000000r 2               ; Calls:	div16_mp
000000r 2               ; Return:	If ptr_a = 0 (array of zeros), then carry is set,
000000r 2               ;		otherwise carry is clear
000000r 2               
000000r 2               .macro	mdiv16	ptr_a, value	; a = a / value (16-bit)
000000r 2               cnton 25
000000r 2               	lday	value
000000r 2               	sty	divisor+0	; big-endian
000000r 2               	sta	divisor+1
000000r 2               	lday	ptr_a
000000r 2               	jsr	div16_mp	; div it
000000r 2               cntoff 25
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Compute arctan(1/value) and store at ptr_a.
000000r 2               ; Input:	ptr_a (16-bit), value (8-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ;		value = 8-bit immediate or absolute/zp integer
000000r 2               ; Calls:	atan_mp
000000r 2               
000000r 2               .macro	matan	ptr_a, value	; a = atan(1/value)
000000r 2               cnton 26
000000r 2               	lday	ptr_a
000000r 2               	ldx	value
000000r 2               	jsr	atan_mp		; atan it
000000r 2               cntoff 26
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Convert and print/display a base 256 number (ptr_a) as
000000r 2               ;		base 10.
000000r 2               ; Input:	ptr_a (16-bit)
000000r 2               ;		ptr_a = pointer to start of allocated array
000000r 2               ; Calls:	print_mp
000000r 2               
000000r 2               .macro	mprint	ptr_a		; print a (base 10)
000000r 2               cnton 27
000000r 2               	lday	ptr_a
000000r 2               	jsr	print_mp	; print it
000000r 2               cntoff 27
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; Description:	Print a string (arg) with an optional trailing character
000000r 2               ;		(usually a carriage return (CR = $0D)).
000000r 2               ; Input:	immediate with extra:		"string",$0D
000000r 2               ;		immediate w/o extra:		"string"
000000r 2               ;		absolue/zp label with extra:	label,$0D
000000r 2               ;		absolue/zp label w/o extra:	label
000000r 2               ; Calls:	print, crout
000000r 2               
000000r 2               .macro	sprint	arg, cr
000000r 2               	.local	str
000000r 2               	.local	skip
000000r 2               	.if .match ({arg},"")
000000r 2               		lday	#str
000000r 2               		jsr	print
000000r 2               		beq	skip
000000r 2               	str:	.byte	arg
000000r 2               	.ifnblank	cr
000000r 2               		.byte	cr
000000r 2               	.endif
000000r 2               		.byte	$0
000000r 2               	skip:
000000r 2               	.else
000000r 2               		lday	#arg
000000r 2               		jsr	print
000000r 2               		.ifnblank	cr
000000r 2               		jsr	crout
000000r 2               		.endif
000000r 2               	.endif
000000r 2               .endmacro
000000r 2               
000000r 1               
000000r 1               
000000r 1               ; Description:	Get time from clock card (if present) and store in "ptr"
000000r 1               ; Input:	16-bit ptr to array of 4 bytes (s,m,h,100th sec)
000000r 1               ; Calls:	gettime
000000r 1               
000000r 1               .macro	time	ptr
000000r 1               	ldx	gotclock
000000r 1               	beq	:+
000000r 1               	lday	#ptr
000000r 1               	jsr	gettime
000000r 1               :
000000r 1               .endmacro
000000r 1               
000000r 1               ;; end of macros
000000r 1               
000000r 1               
000000r 1               ;; use for DOS header, NOTE: will mess with .align statements
000000r 1               	;.byte  <begin,>begin,<(end-begin),>(end-begin)
000000r 1               
000000r 1               
000000r 1               ;; start of real code
000000r 1               	.org	org
000800  1               begin:
000800  1               	;; check for 80 col code here
000800  1               	;; clear/home screen code
000800  1               	; lazy, going to hard code for now, in the future check for //e with
000800  1               	;   80 col card, or //c, IIgs, or Videx, else die
000800  1  A9 00        	lda	#$00		; load up $36/$37
000802  1  85 36        	sta	$36		; with $C300
000804  1  A9 C3        	lda	#$C3		; i.e. pr#3
000806  1  85 37        	sta	$37		; or C300G
000808  1               
000808  1  A2 23        	ldx	#35		; print 35 spaces to center title
00080A  1  A9 A0        :	lda	#' '+$80
00080C  1  20 ED FD     	jsr	cout
00080F  1  CA           	dex
000810  1  D0 F8        	bne	:-
000812  1  A9 1B A0 08  	sprint	"Apple Pi/e",$0D
000816  1  20 D4 19 F0  
00081A  1  0C 41 70 70  
00081E  1  6C 65 20 50  
000822  1  69 2F 65 0D  
000826  1  00           
000827  1  20 8E FD     	jsr	crout		; print CR
00082A  1  20 8E FD     	jsr	crout		; print CR
00082D  1               
00082D  1               	; check for no slot clock
00082D  1  20 2B 1A     	jsr	detect_noslotclock
000830  1  90 2A        	bcc	:+		; if carry clear, no 'no slot clock'
000832  1  A9 01        	lda	#1
000834  1  8D CE 0B     	sta	gotclock	; set clock type to 1
000837  1  A9 40 A0 08  	sprint	"'No Slot Clock' detected",$0D
00083B  1  20 D4 19 F0  
00083F  1  1A 27 4E 6F  
000843  1  20 53 6C 6F  
000847  1  74 20 43 6C  
00084B  1  6F 63 6B 27  
00084F  1  20 64 65 74  
000853  1  65 63 74 65  
000857  1  64 0D 00     
00085A  1  F0 40        	beq	setup		; branch to setup
00085C  1               :
00085C  1               	; check for thunderclock card
00085C  1  20 F3 19     	jsr	detect_thunderclock
00085F  1  E0 00        	cpx	#0		; slot returned in x
000861  1  F0 39        	beq	:+		; no thunder clock if x = 0
000863  1  A9 02        	lda	#2
000865  1  8D CE 0B     	sta	gotclock	; set clock type to 2
000868  1  8E CF 0B     	stx	clockslot	; save the card slot number
00086B  1  A9 74 A0 08  	sprint	"Thunderclock detected in slot "
00086F  1  20 D4 19 F0  
000873  1  1F 54 68 75  
000877  1  6E 64 65 72  
00087B  1  63 6C 6F 63  
00087F  1  6B 20 64 65  
000883  1  74 65 63 74  
000887  1  65 64 20 69  
00088B  1  6E 20 73 6C  
00088F  1  6F 74 20 00  
000893  1  8A           	txa			; transfer slot number to A
000894  1  09 B0        	ora	#$B0		; convert to ASCII
000896  1  20 ED FD     	jsr	cout		; print it
000899  1  20 8E FD     	jsr	crout		; CR
00089C  1               :
00089C  1               
00089C  1               setup:				; initial setup
00089C  1  20 8E FD     	jsr	crout		; CR
00089F  1  A9 BA        	lda	#':'+$80	; update prompt char just in case user hits <-
0008A1  1  85 33        	sta	promptc		;   and store it
0008A3  1               
0008A3  1               start:				; prompt for pi or e
0008A3  1  A9 50        	lda	#'P'
0008A5  1  8D CB 0B     	sta	constant
0008A8  1  A9 69        	lda	#'i'
0008AA  1  8D CC 0B     	sta	constant+1
0008AD  1  A9 FF        	lda	#-1
0008AF  1  8D CA 0B     	sta	pie
0008B2  1  A9 BB A0 08  	sprint	"Compute [P]i or [e]? "
0008B6  1  20 D4 19 F0  
0008BA  1  16 43 6F 6D  
0008BE  1  70 75 74 65  
0008C2  1  20 5B 50 5D  
0008C6  1  69 20 6F 72  
0008CA  1  20 5B 65 5D  
0008CE  1  3F 20 00     
0008D1  1  20 0C FD     :	jsr	rdkey		; read one keystroke
0008D4  1  09 A0        	ora	#%10100000	; convert to lower case + $80
0008D6  1  C9 F0        	cmp	#'p'+$80	; got P?
0008D8  1  F0 13        	beq	:++		;   branch two :
0008DA  1  C9 E5        	cmp	#'e'+$80	; got E?
0008DC  1  F0 02        	beq	:+		;   branch one :
0008DE  1  D0 F1        	bne	:-		; none of the above, go back and try again
0008E0  1  EE CA 0B     :	inc	pie		; e,   pie = 1
0008E3  1  A9 65        	lda	#'e'		; wipe out "Pi" and replace with "e",null
0008E5  1  8D CB 0B     	sta	constant
0008E8  1  A9 00        	lda	#0
0008EA  1  8D CC 0B     	sta	constant+1
0008ED  1  EE CA 0B     :	inc	pie		; pi,  pie = 0
0008F0  1  A9 CB A0 0B  	sprint	constant	; display selection
0008F4  1  20 D4 19     
0008F7  1  20 8E FD     	jsr	crout		; print CR
0008FA  1  20 8E FD     	jsr	crout		; print CR
0008FD  1               
0008FD  1               printer:			; prompt for printer code
0008FD  1  A9 06 A0 09  	sprint	"Print to slot (1-7), (0 or RETURN for no printout)? "
000901  1  20 D4 19 F0  
000905  1  35 50 72 69  
000909  1  6E 74 20 74  
00090D  1  6F 20 73 6C  
000911  1  6F 74 20 28  
000915  1  31 2D 37 29  
000919  1  2C 20 28 30  
00091D  1  20 6F 72 20  
000921  1  52 45 54 55  
000925  1  52 4E 20 66  
000929  1  6F 72 20 6E  
00092D  1  6F 20 70 72  
000931  1  69 6E 74 6F  
000935  1  75 74 29 3F  
000939  1  20 00        
00093B  1  20 0C FD     :	jsr	rdkey		; read one keystroke
00093E  1  09 80        	ora	#$80		; set hi bit (it's an apple thing)
000940  1  C9 8D        	cmp	#$8D		; check for return
000942  1  F0 0A        	beq	:+		; jump to fake a zero on display
000944  1  C9 B8        	cmp	#$B8		; >= ASCII 8?
000946  1  B0 F3        	bcs	:-		; yep, try again
000948  1  C9 B0        	cmp	#$B0		; < ASCII 0?
00094A  1  B0 04        	bcs	:++		; nope, move on
00094C  1  90 ED        	bcc	:-		; yep, try again
00094E  1  A9 B0        :	lda	#$B0		; fake a zero
000950  1  20 ED FD     :	jsr	cout		; display slot
000953  1  29 07        	and	#%00000111	; mask off last 3 bits
000955  1  8D C9 0B     	sta	prslot		; save it for later
000958  1  20 8E FD     	jsr	crout		; print CR
00095B  1               
00095B  1               	;; prompt for 6502 or 6809 or both
00095B  1               	; eventually I'll get the 6809 version of this for Stellation 6809
00095B  1               	; co-processor cards
00095B  1               
00095B  1               inputrange:
00095B  1  20 8E FD     	jsr	crout		; print CR
00095E  1  A9 67 A0 09  	sprint	"Number of "
000962  1  20 D4 19 F0  
000966  1  0B 4E 75 6D  
00096A  1  62 65 72 20  
00096E  1  6F 66 20 00  
000972  1  A9 CB A0 0B  	sprint	constant	; Pi or e
000976  1  20 D4 19     
000979  1  A9 82 A0 09  	sprint	" digits (100-22950): "
00097D  1  20 D4 19 F0  
000981  1  16 20 64 69  
000985  1  67 69 74 73  
000989  1  20 28 31 30  
00098D  1  30 2D 32 32  
000991  1  39 35 30 29  
000995  1  3A 20 00     
000998  1  20 6F FD     	jsr	getln1		; get line of input, length in x
00099B  1  E0 06        	cpx	#6		; if x >= 6 (should be int(log10(max)) + 1)
00099D  1  B0 0A        	bcs	rangeerror	;   error out and branch to rangeerror
00099F  1  A9 00        	lda	#0		; put a null at the end of the string
0009A1  1  9D 00 02     	sta	linebuf,x	;   for asciitohex (plus display/printing)
0009A4  1  20 42 19     	jsr	asciitohex	; returns 16-bit hex lo in a and hi in y
0009A7  1  90 32        	bcc	noinputerror	;   if no carry set, then no asciitohex error
0009A9  1               rangeerror:
0009A9  1  20 8E FD     	jsr	crout		; print CR
0009AC  1  A9 B5 A0 09  	sprint	"Digits must be in range 100-22950.",$0D
0009B0  1  20 D4 19 F0  
0009B4  1  24 44 69 67  
0009B8  1  69 74 73 20  
0009BC  1  6D 75 73 74  
0009C0  1  20 62 65 20  
0009C4  1  69 6E 20 72  
0009C8  1  61 6E 67 65  
0009CC  1  20 31 30 30  
0009D0  1  2D 32 32 39  
0009D4  1  35 30 2E 0D  
0009D8  1  00           
0009D9  1  F0 80        	beq	inputrange	; free zero from sprint
0009DB  1               noinputerror:			; check for range error
0009DB  1               				; last operation from asciitohex was ldy (hi)
0009DB  1  D0 04        	bne	highcheck	; check for > 22950
0009DD  1  C9 64        	cmp	#min		; if < 100
0009DF  1  90 C8        	bcc	rangeerror
0009E1  1               highcheck:
0009E1  1  C0 59        	cpy	#>max
0009E3  1  90 06        	bcc	rangeok		; < 22950
0009E5  1  D0 C2        	bne	rangeerror	; > 22950
0009E7  1  C9 A7        	cmp	#(<max)+1	; got hi bits, need to check for lo bits in a
0009E9  1  B0 BE        	bcs	rangeerror	; >= lo bits
0009EB  1               rangeok:
0009EB  1  8D DC 0B     	sta	declen		; save declen lo (declen used for print_mp)
0009EE  1  8D D8 0B     	sta	arraylen	; save arraylen lo
0009F1  1  8C DD 0B     	sty	declen+1	; save declen hi
0009F4  1  8C D9 0B     	sty	arraylen+1	; save arraylen hi
0009F7  1               	; need to add one to range for the "3." that is left of
0009F7  1               	; the decimal digits, i.e. 1000 digits is really 1001
0009F7  1  EE D8 0B     	inc	arraylen	; arraylen++ (lo = lo + 1)
0009FA  1  D0 03        	bne	:+		; if rolled to 0 then
0009FC  1  EE D9 0B     	inc	arraylen+1	; inc arraylen hi
0009FF  1               :	; at this point we have a valid number between 100-22950 inclusive
0009FF  1               	;
0009FF  1               	; compute ceil(number decimal digits * 1/log(256) + 1) to compute
0009FF  1               	; the number of base(256) digits to use
0009FF  1               	;
0009FF  1               	;   1st, multiply arraylen by 1/log(256) (0.6A4D)
0009FF  1               	;   2nd, ceil (round up) the result + 1 guard digit
0009FF  1               	;   3rd, add extra guard digits for accuracy
0009FF  1               
0009FF  1               	; 1. arraylen/log(256)
0009FF  1               	;
0009FF  1               log256:	; fixed point 32-bit math product/result
0009FF  1  A9 00        	lda	#0
000A01  1  85 04        	sta	a32		; right of the decimal (< 0)
000A03  1  85 05        	sta	a32+1
000A05  1  85 06        	sta	a32+2		; left of the decimal (> 0)
000A07  1  85 07        	sta	a32+3
000A09  1  A2 10        	ldx	#16
000A0B  1  D0 08        	bne	:++		; skip first shift
000A0D  1  06 04        :	asl	a32		; shift ...
000A0F  1  26 05        	rol	a32+1
000A11  1  26 06        	rol	a32+2
000A13  1  26 07        	rol	a32+3
000A15  1  0E D8 0B     :	asl	arraylen	; get high bit
000A18  1  2E D9 0B     	rol	arraylen+1
000A1B  1  90 15        	bcc	:+		; zero bit, next
000A1D  1  18           	clc			; ... and add
000A1E  1  A9 4D        	lda	#$4D		; 1/log(256)
000A20  1  65 04        	adc	a32
000A22  1  85 04        	sta	a32
000A24  1  A9 6A        	lda	#$6A		; 1/log(256)
000A26  1  65 05        	adc	a32+1
000A28  1  85 05        	sta	a32+1
000A2A  1  90 06        	bcc	:+		; no carry, no prob
000A2C  1  E6 06        	inc	a32+2		; got carry, inc next MSD
000A2E  1  D0 02        	bne	:+		; inc does not set carry, but if rolled to
000A30  1  E6 07        	inc	a32+3		;   zero, then it's a carry, inc MSD
000A32  1  CA           :	dex			; not zero
000A33  1  D0 D8        	bne	:---		;   then back to top of loop
000A35  1               
000A35  1               	; 2. compute ceil and add a guard digit
000A35  1               	; x = 0 now (free 0!)
000A35  1               	;
000A35  1  A0 02        ceil:	ldy	#2		; assumed ceil + one guard digit
000A37  1               
000A37  1  E4 04        	cpx	a32		; right of decimal not 0?  round up (ceil)
000A39  1  D0 05        	bne	guards		;   truncate and keep Y = 2
000A3B  1  E4 05        	cpx	a32+1		; right of decimal not 0?  round up (ceil)
000A3D  1  D0 01        	bne	guards		;   truncate and keep Y = 2
000A3F  1  88           	dey			; remove assumed ceil (prob never happend)
000A40  1               
000A40  1               	; 3. if declen > 1000 ($3E8), then A = A + 2 more guard digits.
000A40  1               	;
000A40  1  AD DC 0B     guards: lda	declen		; 16-bit compare
000A43  1  C9 E9        	cmp	#<1001		; if # of decimal digits > 1000
000A45  1  AD DD 0B     	lda	declen+1	;   then add two more guard digits, this will
000A48  1  E9 03        	sbc	#>1001		;   be sufficient for up to 22950 digits
000A4A  1  90 02        	bcc	:+		; branch if declen < 1001
000A4C  1  C8           	iny			;   otherwise add two more guard digits
000A4D  1  C8           	iny			;   then transfer to A
000A4E  1  98           :	tya			; A = ceil + guards
000A4F  1  18           	clc			; add guard+ceil digits to /log256
000A50  1  65 06        	adc	a32+2		;   and save in arraylen
000A52  1  8D D8 0B     	sta	arraylen
000A55  1  A9 00        	lda	#0
000A57  1  65 07        	adc	a32+3
000A59  1  8D D9 0B     	sta	arraylen+1
000A5C  1               
000A5C  1               	; almost done
000A5C  1               	;
000A5C  1               	; make arraylen even to optimize Duff Device branch decisions
000A5C  1               	;   this will make the code a bit shorter, but also a bit slower
000A5C  1               	;   on the order of 1/1000ths of seconds or less total time 50% of the
000A5C  1               	;   time, IOW not going to worry about it.
000A5C  1               	;
000A5C  1  AD D8 0B     	lda	arraylen	; load LSB arraylen
000A5F  1  4A           	lsr			; shift LSBit to carry
000A60  1  90 08        	bcc	:+		; is even, then skip
000A62  1  EE D8 0B     	inc	arraylen	; is odd, then plus one to make even
000A65  1  D0 03        	bne	:+		; arraylen rolled to zero?
000A67  1  EE D9 0B     	inc	arraylen+1	; got zero, inc arraylen+1
000A6A  1               :
000A6A  1               	; compute arrayend, used by loops that start from end
000A6A  1               	;
000A6A  1  AD D9 0B     	lda	arraylen+1	; arrayend = arraylen - 1
000A6D  1  8D DB 0B     	sta	arrayend+1
000A70  1  AD D8 0B     	lda	arraylen
000A73  1  8D DA 0B     	sta	arrayend
000A76  1  D0 03        	bne	:+		; check if arraylen (lo) is zero, if zero,
000A78  1  CE DB 0B     	dec	arrayend+1	;   then it will rollback to $FF, so dec (hi)
000A7B  1  CE DA 0B     :	dec	arrayend	; dec (lo)
000A7E  1               
000A7E  1               	; finally done with entry and setup, time for some Pie!!!
000A7E  1               
000A7E  1               initheap:			; setup heap pointer
000A7E  1  A9 99 A0 1E  	lday	#heap		; This is the start of dynamically allocated
000A82  1  85 0C 84 0D  	stay	heapptr		; memory.  This needs to be done each time Pi
000A86  1               				; or e is computed to free up old arrays.
000A86  1               
000A86  1               alloc_pointers:			; allocate all arrays (we need 4 for Pi)
000A86  1  AD D8 0B AC  	alloc	mp_a,arraylen	; allocate mp_a with size arraylen
000A8A  1  D9 0B 20 22  
000A8E  1  19 90 03 4C  
000A92  1  A3 19 8D DE  
000A96  1  0B 8C DF 0B  
000A9A  1  AD D8 0B AC  	alloc	mp_b,arraylen	;   error on failure and die
000A9E  1  D9 0B 20 22  
000AA2  1  19 90 03 4C  
000AA6  1  A3 19 8D E0  
000AAA  1  0B 8C E1 0B  
000AAE  1  AD D8 0B AC  	alloc	mp_x,arraylen
000AB2  1  D9 0B 20 22  
000AB6  1  19 90 03 4C  
000ABA  1  A3 19 8D E2  
000ABE  1  0B 8C E3 0B  
000AC2  1  AD D8 0B AC  	alloc	mp_y,arraylen
000AC6  1  D9 0B 20 22  
000ACA  1  19 90 03 4C  
000ACE  1  A3 19 8D E4  
000AD2  1  0B 8C E5 0B  
000AD6  1               
000AD6  1               				; if printout, enable printer
000AD6  1  AD C9 0B     	lda	prslot		; load prslot value (0-7)
000AD9  1  F0 08        	beq	:+		; if zero no print
000ADB  1  09 C0        	ora	#$C0		; setup redir by storing
000ADD  1  85 37        	sta	$37		; $C<slot>00 in $36/$37
000ADF  1  A9 00        	lda	#$00
000AE1  1  85 36        	sta	$36
000AE3  1               :
000AE3  1               header:				; print header
000AE3  1  20 8E FD     	jsr	crout		; print CR
000AE6  1  A9 EF A0 0A  	sprint	"Computing "
000AEA  1  20 D4 19 F0  
000AEE  1  0B 43 6F 6D  
000AF2  1  70 75 74 69  
000AF6  1  6E 67 20 00  
000AFA  1  A9 CB A0 0B  	sprint	constant
000AFE  1  20 D4 19     
000B01  1  A9 0A A0 0B  	sprint	" to "
000B05  1  20 D4 19 F0  
000B09  1  05 20 74 6F  
000B0D  1  20 00        
000B0F  1  A9 00 A0 02  	sprint	linebuf
000B13  1  20 D4 19     
000B16  1  A9 1F A0 0B  	sprint	" digits..."
000B1A  1  20 D4 19 F0  
000B1E  1  0B 20 64 69  
000B22  1  67 69 74 73  
000B26  1  2E 2E 2E 00  
000B2A  1               
000B2A  1  AE CE 0B F0  	time	starttime	; if clock detected, store start time
000B2E  1  07 A9 D0 A0  
000B32  1  0B 20 36 1A  
000B36  1  8D 01 E1     cnton	1
000B39  1  AD CA 0B     	lda	pie		; check pie flag for pi = 0. e = 1
000B3C  1  F0 05        	beq	:+		; if zero branch to jsr pi
000B3E  1  20 5E 0C     	jsr	e		;   else jsr e
000B41  1  B0 03        	bcs	:++		; carry set after e run
000B43  1  20 E6 0B     :	jsr	pi
000B46  1  20 8E FD     :	jsr	crout
000B49  1  20 8E FD     	jsr	crout
000B4C  1  8D 1B E1 AD  	mprint	mp_a		; print it (note mp_a hosed)
000B50  1  DE 0B AC DF  
000B54  1  0B 20 D8 17  
000B58  1  8D 1B E2     
000B5B  1  20 8E FD     	jsr	crout		; print CR
000B5E  1  8D 01 E2     cntoff	1
000B61  1  AE CE 0B F0  	time	endtime		; if clock detected, start end time
000B65  1  07 A9 D4 A0  
000B69  1  0B 20 36 1A  
000B6D  1  20 8E 1A     	jsr	printtime	;   and print the wallclock time
000B70  1  20 8E FD     	jsr	crout
000B73  1               				; if printout, disable printer
000B73  1  AD C9 0B     	lda	prslot		; load prslot value (0-7)
000B76  1  F0 08        	beq	:+		; if zero no print
000B78  1  A9 00        	lda	#$00		; hard coded load of $C300 in $36/$37
000B7A  1  85 36        	sta	$36		;  i.e. pr#3
000B7C  1  A9 C3        	lda	#$C3
000B7E  1  85 37        	sta	$37
000B80  1               :
000B80  1  A9 89 A0 0B  	sprint	"More Pie? "	; who doesn't want more Pie?
000B84  1  20 D4 19 F0  
000B88  1  0B 4D 6F 72  
000B8C  1  65 20 50 69  
000B90  1  65 3F 20 00  
000B94  1  20 0C FD     :	jsr	rdkey		; read a single keystroke
000B97  1  09 A0        	ora	#%10100000	; convert to lower case + $80
000B99  1  C9 EE        	cmp	#'n'+$80	; check for N or
000B9B  1  F0 1C        	beq	:++
000B9D  1  C9 F9        	cmp	#'y'+$80	; Y
000B9F  1  F0 02        	beq	:+
000BA1  1  D0 F1        	bne	:-		; if not N/Y retry.
000BA3  1  A9 AC A0 0B  :	sprint	"Yes"		; print "Yes" if y
000BA7  1  20 D4 19 F0  
000BAB  1  04 59 65 73  
000BAF  1  00           
000BB0  1  20 8E FD     	jsr	crout
000BB3  1  20 8E FD     	jsr	crout
000BB6  1  4C A3 08     	jmp	start		; start over with all prompts
000BB9  1  A9 C2 A0 0B  :	sprint	"No"		; print "No" if n
000BBD  1  20 D4 19 F0  
000BC1  1  03 4E 6F 00  
000BC5  1  20 8E FD     	jsr	crout		; print CR
000BC8  1  60           	rts			;  and exit
000BC9  1               
000BC9  1               
000BC9  1               ;; end of main code, start of non-zp allocations
000BC9  1               
000BC9  1  00           prslot:	.byte	$0		; Printer slot
000BCA  1  00           pie:	.byte	$0		; Pi or e flag, pi = 0, e = 1
000BCB  1               constant:			; Pi or e text
000BCB  1  00 00 00     	.byte	$0, $0, $0
000BCE  1               gotclock:
000BCE  1  00           	.byte	$0		; clock type
000BCF  1               clockslot:
000BCF  1  00           	.byte	$0		; clock slot
000BD0  1               starttime:
000BD0  1  00 00 00 00  	.byte	$0, $0, $0, $0	; start time (s,m,h,1/100 s)
000BD4  1               endtime:
000BD4  1  00 00 00 00  	.byte	$0, $0, $0, $0	; end time (s,m,h,1/100 s)
000BD8  1               arraylen:
000BD8  1  00 00        	.byte	$0, $0		; length of base 256 array
000BDA  1               arrayend:
000BDA  1  00 00        	.byte	$0, $0		; last byte of array
000BDC  1  00 00        declen:	.byte	$0, $0		; decimal length of digits
000BDE  1  00 00        mp_a:	.byte	$0, $0		; mp pointer
000BE0  1  00 00        mp_b:	.byte	$0, $0		; mp pointer
000BE2  1  00 00        mp_x:	.byte	$0, $0		; mp pointer
000BE4  1  00 00        mp_y:	.byte	$0, $0		; mp pointer
000BE6  1               
000BE6  1               
000BE6  1               ;; start of subs
000BE6  1               
000BE6  1               ; Description: Compute pi using the Gregory expansion of Machin's arctan
000BE6  1               ;              formula and save in array (mp_a) (hardcoded--bad).
000BE6  1               ;
000BE6  1               ;   pi = 4 * (4 *      atan(1/5)           -           atan(1/239)          )
000BE6  1               ;
000BE6  1               ;
000BE6  1               ;   __      /   / 1     1      1       \       / 1       1        1        \\
000BE6  1               ;   || = 4 | 4 |  - - ---- + ---- - ... |  -  | --- - ------ + ------ - ... ||
000BE6  1               ;          |   |  5      3      5       |     | 239        3        5       ||
000BE6  1               ;           \   \     3x5    5x5       /       \      3x239    5x239       //
000BE6  1               ;
000BE6  1               ;
000BE6  1               ; Input:       None
000BE6  1               ;
000BE6  1               ; Output:      (mp_a) = pi = 4 * (4 * atan(1/5) - atan(1/239))
000BE6  1               ;
000BE6  1               ; Clobbered:   A, X, Y
000BE6  1               ;
000BE6  1               ; Calls:       matan/atan_mp, masl/asl_mp, msub/sub_mp
000BE6  1               
000BE6  1  8D 1A E1 AD  pi:	matan	mp_a,#5		; a = atan(1/5)
000BEA  1  DE 0B AC DF  
000BEE  1  0B A2 05 20  
000BF2  1  F9 0C 8D 1A  
000BF6  1  E2           
000BF7  1  8D 15 E1 AD  	masl	mp_a		; a = a * 4
000BFB  1  DE 0B AC DF  
000BFF  1  0B 20 AC 0E  
000C03  1  8D 15 E2     
000C06  1  8D 15 E1 AD  	masl	mp_a
000C0A  1  DE 0B AC DF  
000C0E  1  0B 20 AC 0E  
000C12  1  8D 15 E2     
000C15  1  8D 1A E1 AD  	matan	mp_b,#239	; b = atan(1/239)
000C19  1  E0 0B AC E1  
000C1D  1  0B A2 EF 20  
000C21  1  F9 0C 8D 1A  
000C25  1  E2           
000C26  1  8D 17 E1 AD  	msub	mp_a,mp_b	; a = a - b
000C2A  1  E0 0B AC E1  
000C2E  1  0B 85 02 84  
000C32  1  03 AD DE 0B  
000C36  1  AC DF 0B 20  
000C3A  1  65 0E 8D 17  
000C3E  1  E2           
000C3F  1  8D 15 E1 AD  	masl	mp_a		; a = a * 4
000C43  1  DE 0B AC DF  
000C47  1  0B 20 AC 0E  
000C4B  1  8D 15 E2     
000C4E  1  8D 15 E1 AD  	masl	mp_a
000C52  1  DE 0B AC DF  
000C56  1  0B 20 AC 0E  
000C5A  1  8D 15 E2     
000C5D  1  60           	rts
000C5E  1               
000C5E  1               
000C5E  1               ; Description: Compute e using the infinite series:
000C5E  1               ;
000C5E  1               ;               oo
000C5E  1               ;              =====
000C5E  1               ;              \      1
000C5E  1               ;      e   =    >    --  = 1 + 1/1! + 1/2! + 1/3! + 1/4! + ...
000C5E  1               ;              /     k!
000C5E  1               ;              =====
000C5E  1               ;              k = 0
000C5E  1               ;
000C5E  1               ;              and save in array (mp_a) (hardcoded--bad).
000C5E  1               ;
000C5E  1               ; Input:       None
000C5E  1               ;
000C5E  1               ; Output:      (mp_a) = e = 1 + 1/1! + 1/2! + 1/3! + 1/4! + ...
000C5E  1               ;
000C5E  1               ; Clobbered:   A, X, Y
000C5E  1               ;
000C5E  1               ; Calls:       mset/set_mp, mdiv/div_mp, mdiv16/div16_mp, madd/add
000C5E  1               ;
000C5E  1               ; Globals:     Uses n (16-bit) from atan_mp, mp_a, mp_x
000C5E  1               ;
000C5E  1               ; C Algorithm:
000C5E  1               ;
000C5E  1               ; int n = 1;
000C5E  1               ; setbig(A, 1, 0);
000C5E  1               ; setbig(X, 1, 0);
000C5E  1               ; while(divbig(X, n++))         // while(dividend != 0)
000C5E  1               ;     addbig(A, X);
000C5E  1               
000C5E  1  A9 00        e:	lda	#0		; n = 0
000C60  1  8D E5 0C     	sta	n
000C63  1  8D E6 0C     	sta	n+1
000C66  1  8D 13 E1 AD  	mset	mp_a,#1		; mp_a = 1
000C6A  1  DE 0B AC DF  
000C6E  1  0B A2 01 20  
000C72  1  D5 18 8D 13  
000C76  1  E2           
000C77  1  8D 13 E1 AD  	mset	mp_x,#1		; mp_x = 1
000C7B  1  E2 0B AC E3  
000C7F  1  0B A2 01 20  
000C83  1  D5 18 8D 13  
000C87  1  E2           
000C88  1               e_mp_loop:
000C88  1  EE E5 0C     	inc	n		; n = n + 1
000C8B  1  D0 03        	bne	:+		; n not zero
000C8D  1  EE E6 0C     	inc	n+1		; n rolled to 0, inc n (hi)
000C90  1  AE E6 0C     :	ldx	n+1		; if n < 256 then div else div16
000C93  1  D0 16        	bne	:+		; >= 256 use 16 bit div
000C95  1  8D 18 E1 AD  	mdiv	mp_x,n		; < 256 use 8 bit div
000C99  1  E2 0B AC E3  
000C9D  1  0B AE E5 0C  
000CA1  1  20 6D 0F 8D  
000CA5  1  18 E2        
000CA7  1  B0 39        	bcs	e_mp_end	; dividend = 0, done
000CA9  1  90 1B        	bcc	:++		; still working on it
000CAB  1  8D 19 E1 AD  :	mdiv16	mp_x,n		; div16
000CAF  1  E5 0C AC E6  
000CB3  1  0C 84 08 85  
000CB7  1  09 AD E2 0B  
000CBB  1  AC E3 0B 20  
000CBF  1  65 11 8D 19  
000CC3  1  E2           
000CC4  1  B0 1C        	bcs	e_mp_end	; dividend = 0, done
000CC6  1  8D 16 E1 AD  :	madd	mp_a,mp_x	; a = a + x
000CCA  1  E2 0B AC E3  
000CCE  1  0B 85 02 84  
000CD2  1  03 AD DE 0B  
000CD6  1  AC DF 0B 20  
000CDA  1  1E 0E 8D 16  
000CDE  1  E2           
000CDF  1  4C 88 0C     	jmp	e_mp_loop
000CE2  1               e_mp_end:
000CE2  1  60           	rts
000CE3  1               
000CE3  1               
000CE3  1               ; Description: Compute arctan(1/N) using the Gregory expansion of Machin's
000CE3  1               ;              arctan formula and save in array (ptr_a).
000CE3  1               ;
000CE3  1               ;
000CE3  1               ;                              / 1     1      1       \
000CE3  1               ;              arctan(1/N) =  |  - - ---- + ---- - ... |
000CE3  1               ;                             |  N      3      5       |
000CE3  1               ;                              \     3xN    5xN       /
000CE3  1               ;
000CE3  1               ;
000CE3  1               ; Input:       Y/A (hi/lo) pointer to array
000CE3  1               ;              X = N (8 bit)
000CE3  1               ;
000CE3  1               ; Output:      Y/A (hi/lo) pointer to array = arctan(1/N)
000CE3  1               ;
000CE3  1               ; Clobbered:   A, X, Y
000CE3  1               ;
000CE3  1               ; Calls:       mset/set_mp, mdiv/div_mp, madd/add_mp, msub/sub_mp,
000CE3  1               ;              mdiv16/div16_mp, mcopy/copy_mp
000CE3  1               ;
000CE3  1               ; Globals:     mp_x (16-bit), mp_y (16-bit)
000CE3  1               ;
000CE3  1               ; C Algorithm:
000CE3  1               ;
000CE3  1               ; void atanbig(bignum A, unsigned short x)
000CE3  1               ; {
000CE3  1               ;     bignum X, Y;
000CE3  1               ;     unsigned short n = 1;
000CE3  1               ;
000CE3  1               ;     setbig(X, 1, 0);
000CE3  1               ;     divbig(X, x);
000CE3  1               ;     copybig(A, X);
000CE3  1               ;     x *= x;
000CE3  1               ;     while (1) {
000CE3  1               ;         n += 2;
000CE3  1               ;         divbig(X, x);
000CE3  1               ;         copybig(Y, X);
000CE3  1               ;         if (!divbig(Y, n))      // dividend = 0
000CE3  1               ;             break;
000CE3  1               ;         if (n & 2)
000CE3  1               ;             subbig(A, Y);
000CE3  1               ;         else
000CE3  1               ;             addbig(A, Y);
000CE3  1               ;     }
000CE3  1               ; }
000CE3  1               ;
000CE3  1               ; Locals (not really):
000CE3  1               
000CE3  1  00           regx:	.byte	$0
000CE4  1  00           x2:	.byte	$0		; x^2 if x < 16
000CE5  1  00 00        n:	.byte	$0, $0
000CE7  1  00 00        ptr_a:	.byte	$0, $0
000CE9  1               squares:
000CE9  1  00 01 04 09  	.byte	0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
000CED  1  10 19 24 31  
000CF1  1  40 51 64     
000CF4  1  79 90 A9 C4  	.byte	121, 144, 169, 196, 225
000CF8  1  E1           
000CF9  1               
000CF9  1               atan_mp:
000CF9  1  8D E7 0C     	sta	ptr_a		; store ptr lo from A
000CFC  1  8C E8 0C     	sty	ptr_a+1		; store ptr hi from Y
000CFF  1  8E E3 0C     	stx	regx		; save x
000D02  1               
000D02  1  A9 00        	lda	#0		; n = 1
000D04  1  8D E5 0C     	sta	n
000D07  1  8D E6 0C     	sta	n+1
000D0A  1  EE E5 0C     	inc	n		; n = 1 little endian
000D0D  1               
000D0D  1  8D 13 E1 AD  	mset	mp_x,#1		; mp_x = 1
000D11  1  E2 0B AC E3  
000D15  1  0B A2 01 20  
000D19  1  D5 18 8D 13  
000D1D  1  E2           
000D1E  1  8D 18 E1 AD  	mdiv	mp_x,regx	; mp_x /= regx
000D22  1  E2 0B AC E3  
000D26  1  0B AE E3 0C  
000D2A  1  20 6D 0F 8D  
000D2E  1  18 E2        
000D30  1  8D 14 E1 AD  	mcopy	ptr_a,mp_x	; ptr_a = mp_x
000D34  1  E7 0C AC E8  
000D38  1  0C 85 02 84  
000D3C  1  03 AD E2 0B  
000D40  1  AC E3 0B 20  
000D44  1  E5 0E 8D 14  
000D48  1  E2           
000D49  1               
000D49  1  AE E3 0C     	ldx	regx		; square x if x < 16
000D4C  1  8E E4 0C     	stx	x2
000D4F  1  E0 10        	cpx	#16
000D51  1  B0 06        	bcs	atan_mp_loop
000D53  1  BD E9 0C     	lda	squares,x	; load from squares table
000D56  1  8D E4 0C     	sta	x2		;   and save
000D59  1               
000D59  1               atan_mp_loop:			; main loop
000D59  1               				; n = n + 2
000D59  1  EE E5 0C     	inc	n		; n now even
000D5C  1  D0 03        	bne	:+		; n not zero
000D5E  1  EE E6 0C     	inc	n+1		; n rolled to 0, inc n (hi)
000D61  1  EE E5 0C     :	inc	n		; n to be odd, save to inc (cannot roll from
000D64  1               				;   even to odd)
000D64  1  AE E3 0C     	ldx	regx		; x = x / regx ^ 2
000D67  1  E0 10        	cpx	#16
000D69  1  90 12        	bcc	:+		; x already x*x, one div required
000D6B  1  8D 18 E1 AD  	mdiv	mp_x,x2		; x >= 16, then do two div
000D6F  1  E2 0B AC E3  
000D73  1  0B AE E4 0C  
000D77  1  20 6D 0F 8D  
000D7B  1  18 E2        
000D7D  1  8D 18 E1 AD  :	mdiv	mp_x,x2		;   (faster than 16 bit div)
000D81  1  E2 0B AC E3  
000D85  1  0B AE E4 0C  
000D89  1  20 6D 0F 8D  
000D8D  1  18 E2        
000D8F  1               
000D8F  1  8D 14 E1 AD  	mcopy	mp_y,mp_x	; y = x
000D93  1  E4 0B AC E5  
000D97  1  0B 85 02 84  
000D9B  1  03 AD E2 0B  
000D9F  1  AC E3 0B 20  
000DA3  1  E5 0E 8D 14  
000DA7  1  E2           
000DA8  1               
000DA8  1  AE E6 0C     	ldx	n+1		; if n < 256 then div else div16
000DAB  1  D0 16        	bne	:+		; >= 256 use 16 bit div
000DAD  1  8D 18 E1 AD  	mdiv	mp_y,n		; < 256 use 8 bit div
000DB1  1  E4 0B AC E5  
000DB5  1  0B AE E5 0C  
000DB9  1  20 6D 0F 8D  
000DBD  1  18 E2        
000DBF  1  B0 5C        	bcs	atan_mp_end	; dividend = 0, done
000DC1  1  90 1B        	bcc	:++		; still working on it
000DC3  1  8D 19 E1 AD  :	mdiv16	mp_y,n		; div16
000DC7  1  E5 0C AC E6  
000DCB  1  0C 84 08 85  
000DCF  1  09 AD E4 0B  
000DD3  1  AC E5 0B 20  
000DD7  1  65 11 8D 19  
000DDB  1  E2           
000DDC  1  B0 3F        	bcs	atan_mp_end	; dividend = 0, done
000DDE  1               
000DDE  1  AD E5 0C     :	lda	n		; add or sub
000DE1  1  29 02        	and	#2
000DE3  1  F0 1C        	beq	:+		; add it
000DE5  1  8D 17 E1 AD  	msub	ptr_a,mp_y	; a = a - y
000DE9  1  E4 0B AC E5  
000DED  1  0B 85 02 84  
000DF1  1  03 AD E7 0C  
000DF5  1  AC E8 0C 20  
000DF9  1  65 0E 8D 17  
000DFD  1  E2           
000DFE  1  4C 59 0D     	jmp	atan_mp_loop
000E01  1  8D 16 E1 AD  :	madd	ptr_a,mp_y	; a = a + y
000E05  1  E4 0B AC E5  
000E09  1  0B 85 02 84  
000E0D  1  03 AD E7 0C  
000E11  1  AC E8 0C 20  
000E15  1  1E 0E 8D 16  
000E19  1  E2           
000E1A  1  4C 59 0D     	jmp	atan_mp_loop
000E1D  1               atan_mp_end:
000E1D  1  60           	rts
000E1E  1               
000E1E  1               
000E1E  1               ; Description: Multiprecision add:  a = a + b
000E1E  1               ;
000E1E  1               ; Input:       Y/A (hi/lo) pointer to array (a)
000E1E  1               ;              ptr_mp set by macro to point to array (b)
000E1E  1               ;
000E1E  1               ; Output:      a = a + b
000E1E  1               ;
000E1E  1               ; Clobbered:   A, X, Y
000E1E  1               ;
000E1E  1               ; Globals:     arraylen (16-bit), arrayend (16-bit), zp ptr (16-bit),
000E1E  1               ;              zp ptr_mp (16-bit)
000E1E  1               
000E1E  1               add_mp:
000E1E  1  85 00        	sta	ptr		; store ptr lo from A
000E20  1  98           	tya
000E21  1  18           	clc
000E22  1  6D DB 0B     	adc	arrayend+1	; add number of pages since we have to go
000E25  1  85 01        	sta	ptr+1		;   backwards for add/sub/asl
000E27  1  A5 03        	lda	ptr_mp+1
000E29  1  18           	clc
000E2A  1  6D DB 0B     	adc	arrayend+1	; add number of pages since we have to go
000E2D  1  85 03        	sta	ptr_mp+1	;   backwards for add/sub/asl
000E2F  1  AE DB 0B     	ldx	arrayend+1	; full pages
000E32  1  AC DA 0B     	ldy	arrayend	; partial
000E35  1  18           	clc			; clear carry for many adds
000E36  1  98           	tya
000E37  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
000E39  1  F0 16        	beq	@1		;   even (arrayend odd), so just need to
000E3B  1  D0 06        	bne	@3		;   check for 2nd bit (odd or even # of pairs).
000E3D  1  CA           :	dex
000E3E  1  C6 01        	dec	ptr+1		; previous page of 256
000E40  1  C6 03        	dec	ptr_mp+1	; previous page of 256
000E42  1  88           :	dey
000E43  1  B1 00        @3:	lda	(ptr),y		; a	; do bytes 3,4,...,255
000E45  1  71 02        	adc	(ptr_mp),y	; + b
000E47  1  91 00        	sta	(ptr),y		; a = a + b
000E49  1  88           	dey
000E4A  1  B1 00        @2:	lda	(ptr),y		; a	; do bytes 2,4,...,254
000E4C  1  71 02        	adc	(ptr_mp),y	; + b
000E4E  1  91 00        	sta	(ptr),y		; a = a + b
000E50  1  88           	dey
000E51  1  B1 00        @1:	lda	(ptr),y		; a	; do bytes 1,5,...,253
000E53  1  71 02        	adc	(ptr_mp),y	; + b
000E55  1  91 00        	sta	(ptr),y		; a = a + b
000E57  1  88           	dey
000E58  1  B1 00        @0:	lda	(ptr),y		; a	; do bytes 0,4,...,252
000E5A  1  71 02        	adc	(ptr_mp),y	; + b
000E5C  1  91 00        	sta	(ptr),y		; a = a + b
000E5E  1  98           	tya
000E5F  1  D0 E1        	bne	:-
000E61  1  8A           	txa
000E62  1  D0 D9        	bne	:--
000E64  1  60           	rts
000E65  1               
000E65  1               
000E65  1               ; Description: Multiprecision subtract:  a = a - b
000E65  1               ;
000E65  1               ; Input:       Y/A (hi/lo) pointer to array (a)
000E65  1               ;              ptr_mp set by macro to point to array (b)
000E65  1               ;
000E65  1               ; Output:      a = a - b
000E65  1               ;
000E65  1               ; Clobbered:   A, X, Y
000E65  1               ;
000E65  1               ; Globals:     arraylen (16-bit), arrayend (16-bit), zp ptr (16-bit),
000E65  1               ;              zp ptr_mp (16-bit)
000E65  1               
000E65  1               sub_mp:
000E65  1  85 00        	sta	ptr		; store ptr lo from A
000E67  1  98           	tya
000E68  1  18           	clc
000E69  1  6D DB 0B     	adc	arrayend+1	; add number of pages since we have to go
000E6C  1  85 01        	sta	ptr+1		;   backwards for add/sub/asl
000E6E  1  A5 03        	lda	ptr_mp+1
000E70  1  18           	clc
000E71  1  6D DB 0B     	adc	arrayend+1	; add number of pages since we have to go
000E74  1  85 03        	sta	ptr_mp+1	;   backwards for add/sub/asl
000E76  1  AE DB 0B     	ldx	arrayend+1	; full pages
000E79  1  AC DA 0B     	ldy	arrayend	; partial
000E7C  1  38           	sec			; sec carry for many subs
000E7D  1  98           	tya
000E7E  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
000E80  1  F0 16        	beq	@1		;   even (arrayend odd), so just need to
000E82  1  D0 06        	bne	@3		;   check for 2nd bit (odd or even # of pairs).
000E84  1  CA           :	dex
000E85  1  C6 01        	dec	ptr+1		; previous page of 256
000E87  1  C6 03        	dec	ptr_mp+1	; previous page of 256
000E89  1  88           :	dey
000E8A  1  B1 00        @3:	lda	(ptr),y		; a	; do bytes 3,7,...,255
000E8C  1  F1 02        	sbc	(ptr_mp),y	; - b
000E8E  1  91 00        	sta	(ptr),y		; a = a - b
000E90  1  88           	dey
000E91  1  B1 00        @2:	lda	(ptr),y		; a	; do bytes 2,6,...,254
000E93  1  F1 02        	sbc	(ptr_mp),y	; - b
000E95  1  91 00        	sta	(ptr),y		; a = a - b
000E97  1  88           	dey
000E98  1  B1 00        @1:	lda	(ptr),y		; a	; do bytes 1,5,...,253
000E9A  1  F1 02        	sbc	(ptr_mp),y	; - b
000E9C  1  91 00        	sta	(ptr),y		; a = a - b
000E9E  1  88           	dey
000E9F  1  B1 00        @0:	lda	(ptr),y		; a	; do bytes 0,4,...,252
000EA1  1  F1 02        	sbc	(ptr_mp),y	; - b
000EA3  1  91 00        	sta	(ptr),y		; a = a - b
000EA5  1  98           	tya
000EA6  1  D0 E1        	bne	:-
000EA8  1  8A           	txa
000EA9  1  D0 D9        	bne	:--
000EAB  1  60           	rts
000EAC  1               
000EAC  1               
000EAC  1               ; Description: Multiprecision shift left:  a = a * 2
000EAC  1               ;
000EAC  1               ; Input:       Y/A (hi/lo) pointer to array (a)
000EAC  1               ;
000EAC  1               ; Output:      a = a * 2
000EAC  1               ;
000EAC  1               ; Clobbered:   A, X, Y
000EAC  1               ;
000EAC  1               ; Globals:     arraylen (16-bit), arrayend (16-bit), zp ptr (16-bit),
000EAC  1               
000EAC  1               asl_mp:
000EAC  1  85 00        	sta	ptr		; store ptr lo from A
000EAE  1  98           	tya
000EAF  1  18           	clc
000EB0  1  6D DB 0B     	adc	arrayend+1	; add number of pages since we have to go
000EB3  1  85 01        	sta	ptr+1		;   backwards for add/sub/asl
000EB5  1  AE DB 0B     	ldx	arrayend+1	; full pages
000EB8  1  AC DA 0B     	ldy	arrayend	; partial
000EBB  1  18           	clc			; clear carry for many rols
000EBC  1  98           	tya
000EBD  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
000EBF  1  F0 12        	beq	@1		;   even (arrayend odd), so just need to
000EC1  1  D0 04        	bne	@3		;   check for 2nd bit (odd or even # of pairs).
000EC3  1  CA           :	dex
000EC4  1  C6 01        	dec	ptr+1		; previous page of 256
000EC6  1  88           :	dey
000EC7  1  B1 00        @3:	lda	(ptr),y		; do bytes 3,7,...,255
000EC9  1  2A           	rol
000ECA  1  91 00        	sta	(ptr),y
000ECC  1  88           	dey
000ECD  1  B1 00        @2:	lda	(ptr),y		; do bytes 2,6,...,254
000ECF  1  2A           	rol
000ED0  1  91 00        	sta	(ptr),y
000ED2  1  88           	dey
000ED3  1  B1 00        @1:	lda	(ptr),y		; do bytes 1,5,...,253
000ED5  1  2A           	rol
000ED6  1  91 00        	sta	(ptr),y
000ED8  1  88           	dey
000ED9  1  B1 00        @0:	lda	(ptr),y		; do bytes 0,4,...,252
000EDB  1  2A           	rol
000EDC  1  91 00        	sta	(ptr),y
000EDE  1  98           	tya
000EDF  1  D0 E5        	bne	:-
000EE1  1  8A           	txa
000EE2  1  D0 DF        	bne	:--
000EE4  1  60           	rts
000EE5  1               
000EE5  1               
000EE5  1               ; Description: Multiprecision transfer:  a = b
000EE5  1               ;
000EE5  1               ; Input:       Y/A (hi/lo) pointer to array (b)
000EE5  1               ;              ptr_mp set by macro to point to array (a)
000EE5  1               ;
000EE5  1               ; Output:      a = b
000EE5  1               ;
000EE5  1               ; Clobbered:   A, X, Y
000EE5  1               ;
000EE5  1               ; Globals:     arraylen (16-bit), zp ptr (16-bit), zp ptr_mp (16-bit)
000EE5  1               
000EE5  1               copy_mp:
000EE5  1  85 00        	sta	ptr		; store ptr lo from A
000EE7  1  84 01        	sty	ptr+1		; store ptr hi from Y
000EE9  1  AE D9 0B     	ldx	arraylen+1	; full pages
000EEC  1  AC D8 0B     	ldy	arraylen	; partial pages
000EEF  1  F0 1E        	beq	@0		;   if not process full pages only
000EF1  1  E8           	inx			; bump up x +1 for the partial page
000EF2  1  18           	clc			; adjust to point below source start
000EF3  1  98           	tya			; - ex: ptr = $xx00, arraylen = 1
000EF4  1  65 00        	adc	ptr		; we want ptr = $(xx-1)01, y = $ff (255)
000EF6  1  85 00        	sta	ptr
000EF8  1  B0 02        	bcs	:+
000EFA  1  C6 01        	dec	ptr+1
000EFC  1  18           :	clc			; adjust to point below destination start
000EFD  1  98           	tya			; - ex: ptr_mp = $xxff, arraylen = 2
000EFE  1  65 02        	adc	ptr_mp		; we want ptr_mp = $xx01, y = $fe (254)
000F00  1  85 02        	sta	ptr_mp
000F02  1  B0 02        	bcs	:+
000F04  1  C6 03        	dec	ptr_mp+1
000F06  1  98           :	tya			; adjust y index value, y = -y
000F07  1  49 FF        	eor	#$ff		; one's complement
000F09  1  A8           	tay
000F0A  1  C8           	iny			; two's complement
000F0B  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
000F0D  1  F0 0A        	beq	@2		;   even, so just need to check for 2nd bit
000F0F  1               				;   (odd or even # of pairs).
000F0F  1               				;   Fall through to @0.
000F0F  1               				; NOTE: A = Y - 1, checking A, not Y
000F0F  1               				; if A & %11 = 1, then Y%3 = 2
000F0F  1               				; if A & %11 = 3, then Y%3 = 0
000F0F  1  B1 00        @0:	lda	(ptr),y		; move bytes 0,4,...,252
000F11  1  91 02        	sta	(ptr_mp),y
000F13  1  C8           	iny
000F14  1  B1 00        @1:	lda	(ptr),y		; move bytes 1,5,...,253
000F16  1  91 02        	sta	(ptr_mp),y
000F18  1  C8           	iny
000F19  1  B1 00        @2:	lda	(ptr),y		; move bytes 2,6,...,254
000F1B  1  91 02        	sta	(ptr_mp),y
000F1D  1  C8           	iny
000F1E  1  B1 00        @3:	lda	(ptr),y		; move bytes 3,7,...,255
000F20  1  91 02        	sta	(ptr_mp),y
000F22  1  C8           	iny			; page done ?
000F23  1  D0 EA        	bne	@0		; b: no
000F25  1  E6 01        	inc	ptr+1		; next page
000F27  1  E6 03        	inc	ptr_mp+1
000F29  1  CA           	dex			; full page left ?
000F2A  1  D0 E3        	bne	@0		; b:yes
000F2C  1  60           	rts
000F2D  1               
000F2D  1               
000F2D  1               ; Description: Skip leading zeros (used by div_mp and div16_mp)
000F2D  1               ;
000F2D  1               ; Input:       Y/A (hi/lo) pointer to array (b)
000F2D  1               ;
000F2D  1               ; Output:      None
000F2D  1               ;
000F2D  1               ; Clobbered:   A, X, Y
000F2D  1               ;
000F2D  1               ; Globals:     arraylen (16-bit), zp ptr (16-bit)
000F2D  1               
000F2D  1               skipzeros:
000F2D  1  85 00        	sta	ptr		; store ptr lo from A
000F2F  1  84 01        	sty	ptr+1		; store ptr hi from Y
000F31  1  AE D9 0B     	ldx	arraylen+1	; full pages
000F34  1  AC D8 0B     	ldy	arraylen	; partial pages ?
000F37  1  F0 14        	beq	@0		; b:no - process full pages only
000F39  1  E8           	inx			; bump up x +1 for the partial page
000F3A  1  18           	clc			; adjust to point below source start
000F3B  1  98           	tya			; - ex: ptr = $xx00, arraylen = 1
000F3C  1  65 00        	adc	ptr		; we want ptr = $(xx-1)01, y = $ff (255)
000F3E  1  85 00        	sta	ptr
000F40  1  B0 02        	bcs	:+
000F42  1  C6 01        	dec	ptr+1
000F44  1  98           :	tya			; adjust y index value, y = -y
000F45  1  49 FF        	eor	#$ff		; one's complement
000F47  1  A8           	tay
000F48  1  C8           	iny			; two's complement
000F49  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
000F4B  1  F0 0A        	beq	@2		;   even, so just need to check for 2nd bit
000F4D  1               				;   (odd or even # of pairs).
000F4D  1               				;   Fall through to @0.
000F4D  1               				; NOTE: A = Y - 1, checking A, not Y
000F4D  1               				; if A & %11 = 1, then Y%3 = 2
000F4D  1               				; if A & %11 = 3, then Y%3 = 0
000F4D  1  B1 00        @0:	lda	(ptr),y		; check	0,4,...,252
000F4F  1  D0 1A        	bne	@5
000F51  1  C8           	iny
000F52  1  B1 00        @1:	lda	(ptr),y		; check 1,5,...,253
000F54  1  D0 14        	bne	@4
000F56  1  C8           	iny
000F57  1  B1 00        @2:	lda	(ptr),y		; check 2,6,...,254
000F59  1  D0 10        	bne	@5
000F5B  1  C8           	iny
000F5C  1  B1 00        @3:	lda	(ptr),y		; check 3,7,...,255
000F5E  1  D0 0A        	bne	@4
000F60  1  C8           	iny
000F61  1  D0 EA        	bne	@0
000F63  1  E6 01        	inc	ptr+1		; next page
000F65  1  CA           	dex			; is there another page ?
000F66  1  D0 E5        	bne	@0		; b:yes
000F68  1  38           	sec			; flag: all cells are zero
000F69  1  60           	rts
000F6A  1  88           @4:	dey			; make Y even
000F6B  1  18           @5:	clc			; flag: (ptr),y -> first non-zero cell
000F6C  1  60           	rts
000F6D  1               
000F6D  1               
000F6D  1               ; Description: 16-bit/8-bit divide based on:
000F6D  1               ;              http://6502org.wikidot.com/software-math-intdiv
000F6D  1               ;
000F6D  1               ; Input:       divisor (8-bit), dividend (16-bit) hi: X, lo: dividend
000F6D  1               ;
000F6D  1               ; Output:      divisor (8-bit) unchanged,
000F6D  1               ;              X: remainder (8-bit),
000F6D  1               ;              dividend (8-bit): quotient
000F6D  1               ;
000F6D  1               ; Clobbered:   A, X
000F6D  1               
000F6D  1               .macro	div8
000F6D  1               cnton 60
000F6D  1               
000F6D  1               	txa			; remainder
000F6D  1               	asl	dividend
000F6D  1               	.repeat 8		; unroll 8 times for speed
000F6D  1               	rol
000F6D  1               	bcs	:+
000F6D  1               	cmp	divisor
000F6D  1               	bcc	:++
000F6D  1               :	sbc	divisor
000F6D  1               	sec
000F6D  1               :	rol	dividend
000F6D  1               	.endrepeat
000F6D  1               	tax			; remainder
000F6D  1               
000F6D  1               cntoff 60
000F6D  1               .endmacro
000F6D  1               
000F6D  1               
000F6D  1               ; Description: Divide mp array by 8-bit number.
000F6D  1               ;
000F6D  1               ; Input:       Y(hi)/A(lo) pointer to mp
000F6D  1               ;              X = dividend/denominator
000F6D  1               ;
000F6D  1               ; Output:      (ptr) = (ptr)/x
000F6D  1               ;
000F6D  1               ; Clobbered:   A, X, Y
000F6D  1               ;
000F6D  1               ; Globals:     zp ptr (16-bit), arraylen (16-bit), dividend (8-bit),
000F6D  1               ;              zp xreg (8-bit),
000F6D  1               ;
000F6D  1               ; Calls:       skipzeros, div8(macro)
000F6D  1               ;
000F6D  1               ; C Algorithm:
000F6D  1               ;
000F6D  1               ; short divbig(number, x)
000F6D  1               ; bignum number;
000F6D  1               ; unsigned short x;
000F6D  1               ; {
000F6D  1               ;     dword result;
000F6D  1               ;     short j = 0;
000F6D  1               ;     unsigned short rest = 0;
000F6D  1               ;
000F6D  1               ;     while (number[j] == 0 && j < MAXSIZE)
000F6D  1               ;         j++;
000F6D  1               ;     if (j == MAXSIZE)
000F6D  1               ;         return (0);
000F6D  1               ;     while (j < MAXSIZE) {
000F6D  1               ;         result.w.lo = number[j];
000F6D  1               ;         result.w.hi = rest;
000F6D  1               ;         number[j] = result.L / x;
000F6D  1               ;         rest = result.L % x;
000F6D  1               ;         j++;
000F6D  1               ;     }
000F6D  1               ;     return (1);
000F6D  1               ; }
000F6D  1               
000F6D  1               div_mp:
000F6D  1  86 08        	stx	divisor		; save divisor
000F6F  1  20 2D 0F     	jsr	skipzeros	; skip leading zeros for speed
000F72  1  90 01        	bcc	:+		; carry clear?  continue
000F74  1  60           	rts			;   else all zeros, return to caller
000F75  1  86 0B        :	stx	xreg		; need x reg for speed (carry)
000F77  1  A2 00        	ldx	#0
000F79  1  98           	tya
000F7A  1  29 03        	and	#%11
000F7C  1  F0 0B        	beq	@0		; 00 & 11 = 0
000F7E  1  4A           	lsr			; 00 => 0,0; 01 => 0,1; 10 => 1,0; 11 => 1,1
000F7F  1  F0 7B        	beq	@1		; 01 => 0,1
000F81  1               	;bcc	@2		; 1,0
000F81  1  90 03        	bcc	:+		; long branch
000F83  1               	;bcs	@3		; 1,1
000F83  1  4C E2 10     	jmp	@3		; long branch
000F86  1  4C 6F 10     :	jmp	@2
000F89  1  B1 00        @0:	lda	(ptr),y		; div byte 0,4,...,252
000F8B  1  85 04        	sta	dividend
000F8D  1  8D 3C E1 8A  	div8
000F91  1  06 04 2A B0  
000F95  1  04 C5 08 90  
000F99  1  03 E5 08 38  
000F9D  1  26 04 2A B0  
000FA1  1  04 C5 08 90  
000FA5  1  03 E5 08 38  
000FA9  1  26 04 2A B0  
000FAD  1  04 C5 08 90  
000FB1  1  03 E5 08 38  
000FB5  1  26 04 2A B0  
000FB9  1  04 C5 08 90  
000FBD  1  03 E5 08 38  
000FC1  1  26 04 2A B0  
000FC5  1  04 C5 08 90  
000FC9  1  03 E5 08 38  
000FCD  1  26 04 2A B0  
000FD1  1  04 C5 08 90  
000FD5  1  03 E5 08 38  
000FD9  1  26 04 2A B0  
000FDD  1  04 C5 08 90  
000FE1  1  03 E5 08 38  
000FE5  1  26 04 2A B0  
000FE9  1  04 C5 08 90  
000FED  1  03 E5 08 38  
000FF7  1  A5 04        	lda	dividend
000FF9  1  91 00        	sta	(ptr),y
000FFB  1  C8           	iny
000FFC  1  B1 00        @1:	lda	(ptr),y		; div byte 1,5,...,253
000FFE  1  85 04        	sta	dividend
001000  1  8D 3C E1 8A  	div8
001004  1  06 04 2A B0  
001008  1  04 C5 08 90  
00100C  1  03 E5 08 38  
001010  1  26 04 2A B0  
001014  1  04 C5 08 90  
001018  1  03 E5 08 38  
00101C  1  26 04 2A B0  
001020  1  04 C5 08 90  
001024  1  03 E5 08 38  
001028  1  26 04 2A B0  
00102C  1  04 C5 08 90  
001030  1  03 E5 08 38  
001034  1  26 04 2A B0  
001038  1  04 C5 08 90  
00103C  1  03 E5 08 38  
001040  1  26 04 2A B0  
001044  1  04 C5 08 90  
001048  1  03 E5 08 38  
00104C  1  26 04 2A B0  
001050  1  04 C5 08 90  
001054  1  03 E5 08 38  
001058  1  26 04 2A B0  
00105C  1  04 C5 08 90  
001060  1  03 E5 08 38  
00106A  1  A5 04        	lda	dividend
00106C  1  91 00        	sta	(ptr),y
00106E  1  C8           	iny
00106F  1  B1 00        @2:	lda	(ptr),y		; div byte 2,6,...,254
001071  1  85 04        	sta	dividend
001073  1  8D 3C E1 8A  	div8
001077  1  06 04 2A B0  
00107B  1  04 C5 08 90  
00107F  1  03 E5 08 38  
001083  1  26 04 2A B0  
001087  1  04 C5 08 90  
00108B  1  03 E5 08 38  
00108F  1  26 04 2A B0  
001093  1  04 C5 08 90  
001097  1  03 E5 08 38  
00109B  1  26 04 2A B0  
00109F  1  04 C5 08 90  
0010A3  1  03 E5 08 38  
0010A7  1  26 04 2A B0  
0010AB  1  04 C5 08 90  
0010AF  1  03 E5 08 38  
0010B3  1  26 04 2A B0  
0010B7  1  04 C5 08 90  
0010BB  1  03 E5 08 38  
0010BF  1  26 04 2A B0  
0010C3  1  04 C5 08 90  
0010C7  1  03 E5 08 38  
0010CB  1  26 04 2A B0  
0010CF  1  04 C5 08 90  
0010D3  1  03 E5 08 38  
0010DD  1  A5 04        	lda	dividend
0010DF  1  91 00        	sta	(ptr),y
0010E1  1  C8           	iny
0010E2  1  B1 00        @3:	lda	(ptr),y		; div byte 3,7,...,255
0010E4  1  85 04        	sta	dividend
0010E6  1  8D 3C E1 8A  	div8
0010EA  1  06 04 2A B0  
0010EE  1  04 C5 08 90  
0010F2  1  03 E5 08 38  
0010F6  1  26 04 2A B0  
0010FA  1  04 C5 08 90  
0010FE  1  03 E5 08 38  
001102  1  26 04 2A B0  
001106  1  04 C5 08 90  
00110A  1  03 E5 08 38  
00110E  1  26 04 2A B0  
001112  1  04 C5 08 90  
001116  1  03 E5 08 38  
00111A  1  26 04 2A B0  
00111E  1  04 C5 08 90  
001122  1  03 E5 08 38  
001126  1  26 04 2A B0  
00112A  1  04 C5 08 90  
00112E  1  03 E5 08 38  
001132  1  26 04 2A B0  
001136  1  04 C5 08 90  
00113A  1  03 E5 08 38  
00113E  1  26 04 2A B0  
001142  1  04 C5 08 90  
001146  1  03 E5 08 38  
001150  1  A5 04        	lda	dividend
001152  1  91 00        	sta	(ptr),y
001154  1  C8           	iny			; page done ?
001155  1  F0 03        	beq	:+
001157  1  4C 89 0F     	jmp	@0
00115A  1  C6 0B        :	dec	xreg		; full page left ?
00115C  1  F0 05        	beq	:+
00115E  1  E6 01        	inc	ptr+1		; next page
001160  1  4C 89 0F     	jmp	@0
001163  1  18           :	clc			; non zero result
001164  1  60           	rts
001165  1               
001165  1               
001165  1               ; Description: 32-bit/16-bit divide based on:
001165  1               ;              Apple II firmware (Steve Wozniak) and
001165  1               ;              http://www.txbobsc.com/aal/1983/aal8303.html#a5, and
001165  1               ;              optimized by Anton Treuenfels.
001165  1               ;
001165  1               ; Input:       divisor (16-bit big endian), dividend (32-bit big endian)
001165  1               ;
001165  1               ; Output:      divisor (16-bit big endian) unchanged,
001165  1               ;              dividend (32-bit big endian) hi: remainder
001165  1               ;              dividend (32-bit big endian) lo: quotient
001165  1               ;
001165  1               ; Clobbered:   A, X, Y
001165  1               
001165  1               .macro	div16
001165  1               	ldx	dividend+1	; remainder
001165  1               	ldy	dividend+0	; remainder
001165  1               	.repeat 16		; unroll 16 times for speed
001165  1               	asl	dividend+3	; 5
001165  1               	rol	dividend+2	; 10
001165  1               	txa			; 12
001165  1               	rol			; 14
001165  1               	tax			; 16
001165  1               	tya			; 18
001165  1               	rol			; 20
001165  1               	tay			; 22
001165  1               	cpx	divisor+1	; 25
001165  1               	sbc	divisor+0	; 28
001165  1               	bcc	:+		; 30/31 (no subtraction)
001165  1               	tay			; 32
001165  1               	txa			; 34
001165  1               	sbc	divisor+1	; 37
001165  1               	tax			; 39
001165  1               	inc	dividend+3	; 44 (subtraction)
001165  1               :
001165  1               	.endrepeat
001165  1               	stx	dividend+1	; remainder
001165  1               	sty	dividend+0	; remainder
001165  1               .endmacro
001165  1               
001165  1               
001165  1               ; Description: Divide mp array by 16-bit number.
001165  1               ;
001165  1               ; Input:       Y(hi)/A(lo) pointer to mp
001165  1               ;              divisor (16-bit) set by macro
001165  1               ;
001165  1               ; Output:      (ptr) = (ptr)/divisor
001165  1               ;
001165  1               ; Clobbered:   A, X, Y
001165  1               ;
001165  1               ; Globals:     zp ptr (16-bit), arraylen (16-bit), dividend (32-bit),
001165  1               ;              zp xreg (8-bit), divisor (16-bit)
001165  1               ;
001165  1               ; Calls:       skipzeros, div16(macro), div16_long(macro)
001165  1               ;
001165  1               ; C Algorithm: see div_mp
001165  1               
001165  1               .macro	div16_long
001165  1               	lda	(ptr),y		; load/store LSB of dividend
001165  1               	sta	dividend+2
001165  1               	sty	yreg		; save y for updating array
001165  1               	iny
001165  1               	lda	(ptr),y		; load/store LSB-1 of dividend
001165  1               	sta	dividend+3
001165  1               	div16			; need x and y reg
001165  1               	ldy	yreg		; restore y
001165  1               	lda	quotient+0	; load/store quotient MSB to array
001165  1               	sta	(ptr),y
001165  1               	iny
001165  1               	lda	quotient+1	; load/store quotient LSB to array
001165  1               	sta	(ptr),y
001165  1               	iny
001165  1               .endmacro
001165  1               
001165  1               div16_mp:
001165  1  20 2D 0F     	jsr	skipzeros	; skip leading zeros for speed
001168  1  90 01        	bcc	:+		; carry clear?  continue
00116A  1  60           	rts			;   else all zeros, return to caller
00116B  1  A9 00        :	lda	#0		; clear remainder/carry
00116D  1  85 04        	sta	dividend+0	; MSB (big endian)
00116F  1  85 05        	sta	dividend+1	; MSB-1
001171  1  86 0B        	stx	xreg		; macro div16 needs x reg
001173  1  98           	tya
001174  1  4A           	lsr			; even number of non-zero
001175  1  29 03        	and	#%11		; however there can be an odd number of pairs
001177  1  F0 0E        	beq	@0		; 00 & 11 = 0
001179  1  4A           	lsr			; 00 => 0,0; 01 => 0,1; 10 => 1,0; 11 => 1,1
00117A  1               	;beq	@1		; 01 => 0,1
00117A  1  D0 03        	bne	:+
00117C  1  4C 16 13     	jmp	@1
00117F  1               :	;bcc	@2		; 1,0
00117F  1  90 03        	bcc	:+		; long branch
001181  1               	;bcs	@3		; 1,1
001181  1  4C 34 16     	jmp	@3		; long branch
001184  1  4C A5 14     :	jmp	@2
001187  1  B1 00 85 06  @0:	div16_long
00118B  1  84 0A C8 B1  
00118F  1  00 85 07 A6  
001193  1  05 A4 04 06  
001197  1  07 26 06 8A  
00119B  1  2A AA 98 2A  
00119F  1  A8 E4 09 E5  
0011A3  1  08 90 07 A8  
0011A7  1  8A E5 09 AA  
0011AB  1  E6 07 06 07  
0011AF  1  26 06 8A 2A  
0011B3  1  AA 98 2A A8  
0011B7  1  E4 09 E5 08  
0011BB  1  90 07 A8 8A  
0011BF  1  E5 09 AA E6  
0011C3  1  07 06 07 26  
0011C7  1  06 8A 2A AA  
0011CB  1  98 2A A8 E4  
0011CF  1  09 E5 08 90  
0011D3  1  07 A8 8A E5  
0011D7  1  09 AA E6 07  
0011DB  1  06 07 26 06  
0011DF  1  8A 2A AA 98  
0011E3  1  2A A8 E4 09  
0011E7  1  E5 08 90 07  
001316  1  B1 00 85 06  @1:	div16_long
00131A  1  84 0A C8 B1  
00131E  1  00 85 07 A6  
001322  1  05 A4 04 06  
001326  1  07 26 06 8A  
00132A  1  2A AA 98 2A  
00132E  1  A8 E4 09 E5  
001332  1  08 90 07 A8  
001336  1  8A E5 09 AA  
00133A  1  E6 07 06 07  
00133E  1  26 06 8A 2A  
001342  1  AA 98 2A A8  
001346  1  E4 09 E5 08  
00134A  1  90 07 A8 8A  
00134E  1  E5 09 AA E6  
001352  1  07 06 07 26  
001356  1  06 8A 2A AA  
00135A  1  98 2A A8 E4  
00135E  1  09 E5 08 90  
001362  1  07 A8 8A E5  
001366  1  09 AA E6 07  
00136A  1  06 07 26 06  
00136E  1  8A 2A AA 98  
001372  1  2A A8 E4 09  
001376  1  E5 08 90 07  
0014A5  1  B1 00 85 06  @2:	div16_long
0014A9  1  84 0A C8 B1  
0014AD  1  00 85 07 A6  
0014B1  1  05 A4 04 06  
0014B5  1  07 26 06 8A  
0014B9  1  2A AA 98 2A  
0014BD  1  A8 E4 09 E5  
0014C1  1  08 90 07 A8  
0014C5  1  8A E5 09 AA  
0014C9  1  E6 07 06 07  
0014CD  1  26 06 8A 2A  
0014D1  1  AA 98 2A A8  
0014D5  1  E4 09 E5 08  
0014D9  1  90 07 A8 8A  
0014DD  1  E5 09 AA E6  
0014E1  1  07 06 07 26  
0014E5  1  06 8A 2A AA  
0014E9  1  98 2A A8 E4  
0014ED  1  09 E5 08 90  
0014F1  1  07 A8 8A E5  
0014F5  1  09 AA E6 07  
0014F9  1  06 07 26 06  
0014FD  1  8A 2A AA 98  
001501  1  2A A8 E4 09  
001505  1  E5 08 90 07  
001634  1  B1 00 85 06  @3:	div16_long
001638  1  84 0A C8 B1  
00163C  1  00 85 07 A6  
001640  1  05 A4 04 06  
001644  1  07 26 06 8A  
001648  1  2A AA 98 2A  
00164C  1  A8 E4 09 E5  
001650  1  08 90 07 A8  
001654  1  8A E5 09 AA  
001658  1  E6 07 06 07  
00165C  1  26 06 8A 2A  
001660  1  AA 98 2A A8  
001664  1  E4 09 E5 08  
001668  1  90 07 A8 8A  
00166C  1  E5 09 AA E6  
001670  1  07 06 07 26  
001674  1  06 8A 2A AA  
001678  1  98 2A A8 E4  
00167C  1  09 E5 08 90  
001680  1  07 A8 8A E5  
001684  1  09 AA E6 07  
001688  1  06 07 26 06  
00168C  1  8A 2A AA 98  
001690  1  2A A8 E4 09  
001694  1  E5 08 90 07  
0017C3  1  F0 03        	beq	:+		; done?
0017C5  1  4C 87 11     	jmp	@0
0017C8  1  C6 0B        :	dec	xreg
0017CA  1  F0 05        	beq	:+
0017CC  1  E6 01        	inc	ptr+1		; next page
0017CE  1  4C 87 11     	jmp	@0
0017D1  1  18           :	clc			; non zero result
0017D2  1  60           	rts
0017D3  1               
0017D3  1               
0017D3  1               ; Description: print mp base 10/100
0017D3  1               ;
0017D3  1               ; Input:       Y(hi)/A(lo) pointer to array
0017D3  1               ;
0017D3  1               ; Output:      mp base 10/100 out to screen
0017D3  1               ;
0017D3  1               ; Clobbered:   A, X, Y, input array
0017D3  1               ;
0017D3  1               ; Globals:     zero page: ptr (16-bit) , ptr_mp (16-bit), carry_mp (8-bit),
0017D3  1               ;              arraylen (16-bit)
0017D3  1               ;
0017D3  1               ; Tables:      512 byte mult100_lo/hi: and 100 byte bintobcd:
0017D3  1               ;
0017D3  1               ; Locals:
0017D3  1               
0017D3  1               dlength:
0017D3  1  00 00        	.byte	$0, $0
0017D5  1               ptr_save:
0017D5  1  00           	.byte	$0
0017D6  1  05           five:	.byte	$5		; counts the # of base 100 digits printed
0017D7  1  07           seven:	.byte	$7		; counts the # of sets of 10 digits printed
0017D8  1               
0017D8  1               print_mp:
0017D8  1  85 00        	sta	ptr		; store ptr lo from A
0017DA  1  84 01        	sty	ptr+1		; store ptr hi from Y
0017DC  1  98           	tya
0017DD  1  18           	clc
0017DE  1  6D DB 0B     	adc	arrayend+1	; add number of pages since we have to go
0017E1  1  8D D5 17     	sta	ptr_save	;   backwards for multiply
0017E4  1               
0017E4  1  AD DD 0B     	lda	declen+1	; converting to base 100, so dlength=dlength/2
0017E7  1  4A           	lsr
0017E8  1  8D D4 17     	sta	dlength+1
0017EB  1  AD DC 0B     	lda	declen
0017EE  1  6A           	ror
0017EF  1  8D D3 17     	sta	dlength
0017F2  1               
0017F2  1  A9 05        	lda	#5		; reset five and seven
0017F4  1  8D D6 17     	sta	five		; used for pretty output
0017F7  1  A9 07        	lda	#7
0017F9  1  8D D7 17     	sta	seven
0017FC  1               				; print left of decimal
0017FC  1  A0 00        	ldy	#0		; get first digit in array (big endian)
0017FE  1  B1 00        	lda	(ptr),y
001800  1  AA           	tax			; now convert from hex to dec
001801  1  BD 4B 1B     	lda	bintobcd,x	; table lookup
001804  1  C9 0A        	cmp	#10		; if less than 10 skip leading zero
001806  1  90 06        	bcc	:+
001808  1  20 DA FD     	jsr	prbyte		; print it, only A gets hosed, safe to call
00180B  1  4C 14 18     	jmp	period
00180E  1  18           :	clc			; no leading zero code
00180F  1  69 B0        	adc	#$B0		;   convert single digit to ascii
001811  1  20 ED FD     	jsr	cout		;   print it
001814  1  A9 AE        period:	lda	#'.'+$80	; print decimal point (fixed point math)
001816  1  20 ED FD     	jsr	cout		;   print it
001819  1               
001819  1               print_mp1:			; loop through rest of decimal digits
001819  1  A0 00        	ldy	#0		; array[0] = 0
00181B  1  A9 00        	lda	#0
00181D  1  91 00        	sta	(ptr),y
00181F  1  85 04        	sta	carry_mp	; clear multiprecision carry
001821  1               
001821  1  A5 00        	lda	ptr		; ptr_mp to get hosed, must be restored
001823  1  85 02        	sta	ptr_mp
001825  1  AD D5 17     	lda	ptr_save	; add number of pages since we have to go
001828  1  85 03        	sta	ptr_mp+1	;   backwards for multiply (right -> left)
00182A  1               
00182A  1               	; multi array x 100
00182A  1               	; loop from LSB to MSB
00182A  1               	; 16-bit product = array[i] * 100 + carry_mp;
00182A  1               	; array[i] = product lo
00182A  1               	; carry_mp = product hi
00182A  1               	;
00182A  1               	; C Algorithm:
00182A  1               	;
00182A  1               	;    while (j >= 0) {
00182A  1                       ;	result.L = (long) number[j] * 100 + carry;
00182A  1                       ;	number[j] = result.w.lo;
00182A  1                       ;	carry = result.w.hi;
00182A  1                       ;	j--;
00182A  1                   	;    }
00182A  1               
00182A  1               	.macro	mult100
00182A  1               	lda	(ptr_mp),y	; get it
00182A  1               	tax
00182A  1               	lda	mult100_lo,x	; get product lo
00182A  1               	clc
00182A  1               	adc	carry_mp	; add carry_mp to it
00182A  1               	sta	(ptr_mp),y	;   and save it
00182A  1               	lda	mult100_hi,x	; get product hi
00182A  1               	adc	#0		;   add carry if present
00182A  1               	sta	carry_mp	;   and save it
00182A  1               	.endmacro
00182A  1               
00182A  1  AE DB 0B     	ldx	arrayend+1	; full pages
00182D  1  86 0B        	stx	xreg
00182F  1  AC DA 0B     	ldy	arrayend	; partial
001832  1  98           	tya
001833  1  29 02        	and	#%10		; Duff's Device.   We know that arraylen is
001835  1  F0 2D        	beq	@1		;   even (arrayend odd), so just need to
001837  1  D0 05        	bne	@3		;   check for 2nd bit (odd or even # of pairs).
001839  1  C6 0B        :	dec	xreg
00183B  1  C6 03        	dec	ptr_mp+1	; previous page of 256
00183D  1  88           :	dey
00183E  1  B1 02 AA BD  @3:	mult100
001842  1  00 1C 18 65  
001846  1  04 91 02 BD  
00184A  1  00 1D 69 00  
00184E  1  85 04        
001850  1  88           	dey
001851  1  B1 02 AA BD  @2:	mult100
001855  1  00 1C 18 65  
001859  1  04 91 02 BD  
00185D  1  00 1D 69 00  
001861  1  85 04        
001863  1  88           	dey
001864  1  B1 02 AA BD  @1:	mult100
001868  1  00 1C 18 65  
00186C  1  04 91 02 BD  
001870  1  00 1D 69 00  
001874  1  85 04        
001876  1  88           	dey
001877  1  B1 02 AA BD  @0:	mult100
00187B  1  00 1C 18 65  
00187F  1  04 91 02 BD  
001883  1  00 1D 69 00  
001887  1  85 04        
001889  1  98           	tya
00188A  1  D0 B1        	bne	:-
00188C  1  A6 0B        	ldx	xreg
00188E  1  D0 A9        	bne	:--
001890  1               
001890  1               	; print array[0] (MSB)
001890  1  A0 00        	ldy	#0		; get first digit in array
001892  1  B1 00        	lda	(ptr),y
001894  1  AA           	tax			; now convert from hex to dec
001895  1  BD 4B 1B     	lda	bintobcd,x
001898  1  20 DA FD     	jsr	prbyte		; print it, only A gets hosed, safe to call
00189B  1               
00189B  1  CE D6 17     	dec	five		; five=five-1 for each base100 digit printed
00189E  1  D0 1F        	bne	:+		; if five base100 digits printed
0018A0  1  A9 05        	lda	#5		;   then reset five count
0018A2  1  8D D6 17     	sta	five		;   and print a space
0018A5  1  A9 A0        	lda	#' '+$80
0018A7  1  20 ED FD     	jsr	cout
0018AA  1  CE D7 17     	dec	seven		; seven=seven-1 for each set of 10 digits prted
0018AD  1  D0 10        	bne	:+		; if 7 sets of 10 printed
0018AF  1  A9 07        	lda	#7		;   then reset seven count
0018B1  1  8D D7 17     	sta	seven		;   and print a CR
0018B4  1  20 8E FD     	jsr	crout		;   then print 2 spaces
0018B7  1  A9 A0        	lda	#' '+$80
0018B9  1  20 ED FD     	jsr	cout
0018BC  1  20 ED FD     	jsr	cout
0018BF  1               :
0018BF  1               				; dlength = dlength - 1
0018BF  1  AD D3 17     	lda	dlength		; check if dlength = 0
0018C2  1  D0 03        	bne	:+		;   if so, it will roll to $FF
0018C4  1  CE D4 17     	dec	dlength+1	;     so dec dlength+1
0018C7  1  CE D3 17     :	dec	dlength		; dec dlength
0018CA  1  D0 06        	bne	:+		; check dlength and dlength+1 for zeros
0018CC  1  AD D4 17     	lda	dlength+1	;
0018CF  1  D0 01        	bne	:+
0018D1  1  60           	rts			; dlength = 0, all done
0018D2  1  4C 19 18     :	jmp	print_mp1	;
0018D5  1               
0018D5  1               
0018D5  1               ; Description: set array initial value
0018D5  1               ;
0018D5  1               ; Input:       Y(hi)/A(lo) pointer to mp
0018D5  1               ;              X = value left of decimal
0018D5  1               ;
0018D5  1               ; Output:      (ptr),0 = X
0018D5  1               ;              (ptr),1 - (ptr),length-1 = 0
0018D5  1               ;
0018D5  1               ; Clobbered:   A, X, Y
0018D5  1               ;
0018D5  1               ; Globals:     arraylen (16-bit), zp length (16-bit), zp ptr (16-bit)
0018D5  1               
0018D5  1               set_mp:
0018D5  1  85 00        	sta	ptr		; store ptr lo from A
0018D7  1  84 01        	sty	ptr+1		; store ptr hi from Y
0018D9  1  A0 00        	ldy	#0		; left of decimal
0018DB  1  8A           	txa
0018DC  1  91 00        	sta	(ptr),y		; store initial value
0018DE  1  E6 00        	inc	ptr		; bump up pointer
0018E0  1  D0 02        	bne	:+		;  to next digit
0018E2  1  E6 01        	inc	ptr+1		;  rest of array will be 0
0018E4  1  AE DB 0B     : 	ldx	arrayend+1	; full pages (hack, arrayend = arraylen - 1)
0018E7  1  AC DA 0B     	ldy	arrayend	; partial pages
0018EA  1  F0 18        	beq	@0		;   if not process full pages only
0018EC  1  E8           	inx			; bump up x +1 for the partial page
0018ED  1  18           	clc			; adjust to point below source start
0018EE  1  98           	tya			; - ex: ptr = $xx00, arraylen = 1
0018EF  1  65 00        	adc	ptr		; we want ptr = $(xx-1)01, y = $ff (255)
0018F1  1  85 00        	sta	ptr
0018F3  1  B0 02        	bcs	:+
0018F5  1  C6 01        	dec	ptr+1
0018F7  1  98           :	tya			; adjust y index value, y = -y
0018F8  1  49 FF        	eor	#$ff		; one's complement
0018FA  1  A8           	tay
0018FB  1  C8           	iny			; two's complement
0018FC  1  4A           	lsr			; lsr lsr will put 2nd bit in carry status
0018FD  1  4A           	lsr			; remember checking A here not Y
0018FE  1  A9 00        	lda	#0		; A must be set to #0 to clear array
001900  1               				; use carry to check for one/even pairs
001900  1               				; Duff's Device.   We know that arrayend is
001900  1  90 05        	bcc	@1		;   odd, so just need to check for 2nd bit
001902  1  B0 09        	bcs	@3		;   (odd or even # of pairs).
001904  1               				; NOTE: A = Y - 1, checking A, not Y
001904  1               				; if A & %10 = 0, then Y%3 = 1
001904  1               				; if A & %10 = 2, then Y%3 = 3
001904  1  91 00        @0:	sta	(ptr),y		; move even byte (0, 2, ..., 254)
001906  1  C8           	iny
001907  1  91 00        @1:	sta	(ptr),y		; move odd byte (1, 3, ..., 255)
001909  1  C8           	iny			; page done ?
00190A  1  91 00        @2:	sta	(ptr),y		; move even byte (0, 2, ..., 254)
00190C  1  C8           	iny
00190D  1  91 00        @3:	sta	(ptr),y		; move odd byte (1, 3, ..., 255)
00190F  1  C8           	iny			; page done ?
001910  1  D0 F2        	bne	@0		; b: no
001912  1  E6 01        	inc	ptr+1		; next page
001914  1  CA           	dex			; full page left ?
001915  1  D0 ED        	bne	@0
001917  1  60           	rts
001918  1               
001918  1               
001918  1               ; Description: Memory Allocation.  If you call malloc_pb it will move
001918  1               ;              heapptr up to start of next page and if allocation fails
001918  1               ;              it will not restore (yeah, it's a bug).  malloc will
001918  1               ;              allocate from the start of heapptr.  init_heap must be
001918  1               ;              called ONCE before any malloc calls.
001918  1               ;
001918  1               ; Input:       Y(hi)/A(lo) length of array
001918  1               ;
001918  1               ; Output:      Y(hi)/A(lo) pointer to array
001918  1               ;              CARRY=0: OK
001918  1               ;              CARRY=1: ERROR
001918  1               ;
001918  1               ; Clobbered:   A, X, Y, heapptr
001918  1               ;
001918  1               ; Allocation:  dynamic, returned by pointer
001918  1               ;
001918  1               malloc_pb:
001918  1  A6 0C        	ldx	heapptr		; check to see if already on page start
00191A  1  F0 06        	beq	malloc		; on page? (lo = 0) move ahead with malloc
00191C  1  A2 00        	ldx	#0		; not on page, zero out lo
00191E  1  86 0C        	stx	heapptr		;
001920  1  E6 0D        	inc	heapptr+1	; bump up hi
001922  1               malloc:
001922  1  18           	clc
001923  1  65 0C        	adc	heapptr		; add heapptr lo to a
001925  1  AA           	tax			; save it in x
001926  1  98           	tya			; copy y to a
001927  1  65 0D        	adc	heapptr+1	; add heapptr hi to a
001929  1  A8           	tay			; save it in y
00192A  1  C0 BF        	cpy	#>heapend	; cmp with heapend hi
00192C  1  90 08        	bcc	:+		; is < heapend hi ok
00192E  1  D0 0F        	bne	:++		; is > heapend hi not ok
001930  1  E0 FF        	cpx	#<heapend	; is = headend hi need to check lo
001932  1  90 02        	bcc	:+		; is < heapend lo
001934  1  D0 09        	bne	:++		; is > heapend lo
001936  1  A5 0D        :	lda	heapptr+1	; get old heap hi in a
001938  1  84 0D        	sty	heapptr+1	; save new heapptr from y
00193A  1  A8           	tay			; copy a to y to return
00193B  1  A5 0C        	lda	heapptr		; load old head lo in a
00193D  1  86 0C        	stx	heapptr		; update heapptr with new from x
00193F  1  60           :	rts			; SEC set error
001940  1               
001940  1               
001940  1               ; Description: Convert string of ASCII to 16-bit hex.  Bug: no
001940  1               ;              overflow reported.  Keep strings to 5 digits.
001940  1               ;
001940  1               ; Input:       pointer to null terminated string in linebuf
001940  1               ;
001940  1               ; Output:      16-bit unsigned value in Y(hi)/A(lo)
001940  1               ;              CARRY=0: OK
001940  1               ;              CARRY=1: ERROR
001940  1               ;
001940  1               ; Clobbered:   A, Y, X
001940  1               ;
001940  1               ; Globals:     linebuf
001940  1               ;
001940  1               ; Locals:  hex (16-bit)
001940  1               
001940  1  00 00        hex:	.byte	$0, $0
001942  1               
001942  1               asciitohex:
001942  1  A9 00        	lda	#0		; setup hex with with 0
001944  1  8D 40 19     	sta	hex
001947  1  8D 41 19     	sta	hex+1
00194A  1  A2 00        	ldx	#0		; main loop
00194C  1  F0 27        	beq	asciitohex2	; get first digit
00194E  1               asciitohex1:
00194E  1               	; hex = hex * 10
00194E  1               	; hex = hex * (2 + 8)
00194E  1  18           	clc
00194F  1  0E 40 19     	asl	hex
001952  1  2E 41 19     	rol	hex+1		; * 2
001955  1  AD 40 19     	lda	hex		; save lo byte
001958  1  AC 41 19     	ldy	hex+1		; save hi byte
00195B  1  0E 40 19     	asl	hex
00195E  1  2E 41 19     	rol	hex+1		; * 4
001961  1  0E 40 19     	asl	hex
001964  1  2E 41 19     	rol	hex+1		; * 8
001967  1               	; add together hex * 2 (in a and y) to hex * 8
001967  1               	; hex = hex * 2 + hex * 8
001967  1  18           	clc
001968  1  6D 40 19     	adc	hex		; a + lo hex
00196B  1  8D 40 19     	sta	hex		; store it
00196E  1  98           	tya			; get hi hex
00196F  1  6D 41 19     	adc	hex+1		; add with carry and
001972  1  8D 41 19     	sta	hex+1		; store it
001975  1               asciitohex2:
001975  1  BD 00 02     	lda	linebuf,x	; get next ascii
001978  1  29 7F        	and	#$7F		; strip off 8th bit (Apple II issue)
00197A  1  C9 3A        	cmp	#$3A		; ascii should be between $30-$39
00197C  1  90 01        	bcc	:+		; if < $3A ok
00197E  1  60           	rts			; else >= 40 and return with carry high
00197F  1  C9 30        :	cmp	#$30		; if >= $30 ok
001981  1  B0 02        	bcs	:+		;
001983  1  38           	sec			; use SEC for error flag
001984  1  60           	rts			; return error
001985  1  29 0F        :	and	#$0F		; mask off 4 high bits to get decimal number
001987  1  18           	clc			; clear carry
001988  1  6D 40 19     	adc	hex		; add to hex lo
00198B  1  8D 40 19     	sta	hex		; save it
00198E  1  90 03        	bcc	:+		; no carry, no problem
001990  1  EE 41 19     	inc	hex+1		; got carry, inc hex hi
001993  1  E8           :	inx			; inc x
001994  1  BD 00 02     	lda	linebuf,x	; get next ascii
001997  1  F0 02        	beq	:+		; got null/EOL exit out
001999  1  D0 B3        	bne	asciitohex1	; get next digit
00199B  1               :
00199B  1  AD 40 19     	lda	hex		; return results in a (lo) and y (hi)
00199E  1  AC 41 19     	ldy	hex+1
0019A1  1  18           	clc			; clear carry to indicate no error
0019A2  1  60           	rts
0019A3  1               
0019A3  1               
0019A3  1               ; Description: Failed to allocation memory error and die
0019A3  1               ;
0019A3  1               ; Input:       Nada
0019A3  1               ;
0019A3  1               ; Output:      String to screen, then exit code
0019A3  1               ;
0019A3  1               ; Clobbered:   A, Y, X, ptr
0019A3  1               ;
0019A3  1               ; Globals:     zp ptr (16-bit)
0019A3  1               
0019A3  1               malloc_error:
0019A3  1  20 8E FD     	jsr	crout		; print CR
0019A6  1  A9 AF A0 19  	sprint	"*** MEMORY ALLOCATION FAILED ***",$0D
0019AA  1  20 D4 19 F0  
0019AE  1  22 2A 2A 2A  
0019B2  1  20 4D 45 4D  
0019B6  1  4F 52 59 20  
0019BA  1  41 4C 4C 4F  
0019BE  1  43 41 54 49  
0019C2  1  4F 4E 20 46  
0019C6  1  41 49 4C 45  
0019CA  1  44 20 2A 2A  
0019CE  1  2A 0D 00     
0019D1  1  4C 69 FF     	jmp	warm
0019D4  1               
0019D4  1               
0019D4  1               ; Description: Print a string.
0019D4  1               ;
0019D4  1               ; Input:       Y(hi)/A(lo) pointer to string
0019D4  1               ;
0019D4  1               ; Output:      String to screen
0019D4  1               ;
0019D4  1               ; Clobbered:   A, Y, X, ptr
0019D4  1               ;
0019D4  1               ; Globals:     zp ptr (16-bit)
0019D4  1               
0019D4  1  85 00 84 01  print:	stay	ptr		; load Y/A (hi/lo) in ptr
0019D8  1  A0 00        	ldy	#0		; start with first char
0019DA  1  B1 00        	lda	(ptr),y		; load initial char
0019DC  1  09 80        :	ora	#$80		; we do not want flashing or inverse
0019DE  1               				;  (its an Apple II thing)
0019DE  1  20 ED FD     	jsr     cout		; call apple II char out
0019E1  1  C8           	iny			; y++
0019E2  1  B1 00        	lda	(ptr),y		; get next char
0019E4  1  D0 F6        	bne	:-		; not NULL? then print it
0019E6  1  60           	rts			; all done, move alone
0019E7  1               
0019E7  1               
0019E7  1               ; Description: Multiple 8-bit number by 10:  A = A * 10
0019E7  1               ;
0019E7  1               ; Input:       A (8-bit)
0019E7  1               ;
0019E7  1               ; Output:      A (8-bit)
0019E7  1               ;
0019E7  1               ; Clobbered:   A
0019E7  1               ;
0019E7  1               ; Locals:
0019E7  1               
0019E7  1  00           x10tmp:	.byte	$0
0019E8  1               
0019E8  1               x10:
0019E8  1  0A           	asl			; 2 x
0019E9  1  8D E7 19     	sta	x10tmp		; save it
0019EC  1  0A           	asl			; 4 x
0019ED  1  0A           	asl			; 8 x
0019EE  1  18           	clc
0019EF  1  6D E7 19     	adc	x10tmp		; 8 x + 2 x
0019F2  1  60           	rts
0019F3  1               
0019F3  1               
0019F3  1               ; Description: Detect Thunderclock card
0019F3  1               ;
0019F3  1               ; Output:      X = slot of card, else 0
0019F3  1               ;
0019F3  1               ; Clobbered:   A, X, Y
0019F3  1               
0019F3  1               detect_thunderclock:
0019F3  1  A2 08        	ldx	#8		; start at slot 7
0019F5  1  CA           :	dex			; count down the slots
0019F6  1  F0 32        	beq	:+		;   got to zero?  then no card, return
0019F8  1  8A           	txa			; setup pointer at $CN08
0019F9  1  09 C0        	ora	#$C0
0019FB  1  85 01        	sta	ptr+1
0019FD  1  A9 08        	lda	#$08
0019FF  1  85 00        	sta	ptr
001A01  1  A0 00        	ldy	#0		; check for 38 B0 01
001A03  1  B1 00        	lda	(ptr),y
001A05  1  C9 38        	cmp	#$38
001A07  1  D0 EC        	bne	:-		; This isn't the card you are looking for.
001A09  1  C8           	iny
001A0A  1  B1 00        	lda	(ptr),y
001A0C  1  C9 B0        	cmp	#$B0
001A0E  1  D0 E5        	bne	:-		; This isn't the card you are looking for.
001A10  1  C8           	iny
001A11  1  B1 00        	lda	(ptr),y
001A13  1  C9 01        	cmp	#$01
001A15  1  D0 DE        	bne	:-		; This isn't the card you are looking for.
001A17  1  8A           	txa			; Found it!
001A18  1               				;   This IS the card you are looking for.
001A18  1  09 C0        	ora	#$C0		; write out location of card
001A1A  1  8D 68 1A     	sta	rdtcp+2		;   This is self-mod code,
001A1D  1  8D 65 1A     	sta	wdtcp+2		;   generally, not a great idea.
001A20  1  A9 08        	lda	#$08		;   wdtcp/rdtcp to be used later
001A22  1  8D 67 1A     	sta	rdtcp+1
001A25  1  A9 0B        	lda	#$0B
001A27  1  8D 64 1A     	sta	wdtcp+1
001A2A  1  60           :	rts			; if x > 0, found it
001A2B  1               
001A2B  1               
001A2B  1               ; Description: Detect "No Slot Clock".  This is very hackish and can return
001A2B  1               ;              a false positive (just try it on the IIgs).  I could not find
001A2B  1               ;              any docs on how to detect the clock, other than to try to read
001A2B  1               ;              it.  The read code is a disassembly of the clockread DOS
001A2B  1               ;              utility.  To validate success the day of week must be 1, 2, 3,
001A2B  1               ;              4, 5, 6, or 7.  Week/weak check (ha! that was awesome :-).
001A2B  1               ;              I should probably check for proper ranges for all values to
001A2B  1               ;              reduce the risk of a false positive.
001A2B  1               ;
001A2B  1               ; Output:      CARRY set = success or false positive
001A2B  1               ;              CARRY cleared (0) = no no slot clock found
001A2B  1               ;
001A2B  1               ; Clobbered:   A, X, Y
001A2B  1               ;
001A2B  1               ; Globals:     nsc_dy
001A2B  1               
001A2B  1               detect_noslotclock:
001A2B  1  20 00 1E     	jsr	read_noslotclock
001A2E  1  18           	clc			; assume no clock
001A2F  1  AD 06 1E     	lda	nsc_dy		; load day of week
001A32  1  F0 01        	beq	:+		; must be 1 - 7
001A34  1  38           	sec			; set carry if clock
001A35  1  60           :	rts
001A36  1               
001A36  1               
001A36  1               ; Description: If there is a clock, then load the time into (ptr)
001A36  1               ;
001A36  1               ; Input:       Y(hi)/A(lo) 16-bit pointer to 4-byte array
001A36  1               ;              gotclock = 0, no clock, otherwise it is the type of clock:
001A36  1               ;                1 = thunderclock
001A36  1               ;                2 = no slot clock
001A36  1               ;
001A36  1               ; Output:      4-byte array  = s,m,h,1/100s (1/100 if supported by clock)
001A36  1               ;
001A36  1               ; Clobbered:   A, X, Y
001A36  1               ;
001A36  1               ; Globals:     ptr(16-bit), gotclock(8-bit, read-only), nsc_s(8-bit),
001A36  1               ;              nsc_m(8-bit), nsc_h(8-bit), nsc_ss(8-bit)
001A36  1               ;
001A36  1               ; Calls:       read_noslotclock
001A36  1               
001A36  1               gettime:
001A36  1  85 00        	sta	ptr
001A38  1  84 01        	sty	ptr+1
001A3A  1               
001A3A  1  AD CE 0B     	lda	gotclock
001A3D  1  D0 01        	bne	:+
001A3F  1  60           	rts
001A40  1  C9 01        :	cmp	#1		; no slot clock
001A42  1  D0 1D        	bne	thunder
001A44  1  20 00 1E     	jsr	read_noslotclock
001A47  1  A0 00        	ldy	#0
001A49  1  AD 09 1E     	lda	nsc_s
001A4C  1  91 00        	sta	(ptr),y
001A4E  1  C8           	iny
001A4F  1  AD 08 1E     	lda	nsc_m
001A52  1  91 00        	sta	(ptr),y
001A54  1  C8           	iny
001A55  1  AD 07 1E     	lda	nsc_h
001A58  1  91 00        	sta	(ptr),y
001A5A  1  C8           	iny
001A5B  1  AD 0A 1E     	lda	nsc_ss
001A5E  1  91 00        	sta	(ptr),y
001A60  1  60           	rts
001A61  1               thunder:			; must be thunderclock
001A61  1  A9 A3        	lda	#$A3
001A63  1  20 63 1A     wdtcp:	jsr	wdtcp		; self mod code, set read format
001A66  1  20 66 1A     rdtcp:	jsr	rdtcp		; self mod code, read time into linebuf
001A69  1               				; parse out the thunderclock output from
001A69  1  A0 00        	ldy	#0		;   linebuf, y holds the number of pairs to
001A6B  1  A2 11        	ldx	#17		;   get (SS,MM,HH)
001A6D  1  CA           :	dex
001A6E  1  BD 00 02     	lda	linebuf,x	; get 1's place
001A71  1  49 B0        	eor	#$B0		; ASCII to decimal
001A73  1  91 00        	sta	(ptr),y		; store it
001A75  1  CA           	dex
001A76  1  BD 00 02     	lda	linebuf,x	; get 10's place
001A79  1  49 B0        	eor	#$B0		; ASCII to decimal
001A7B  1  20 E8 19     	jsr	x10		; a = a * 10
001A7E  1  18           	clc
001A7F  1  71 00        	adc	(ptr),y		; add to 1's
001A81  1  91 00        	sta	(ptr),y		; store number (range 0-99)
001A83  1  CA           	dex			; skip comma
001A84  1  C8           	iny			; next pair
001A85  1  C0 03        	cpy	#3		; got 3rd pair?
001A87  1  D0 E4        	bne	:-		;   no, then get next pair
001A89  1  A9 00        	lda	#0		; There is no 1/100 with thunderclock so set
001A8B  1  91 00        	sta	(ptr),y		;   1/100 to 0
001A8D  1  60           	rts
001A8E  1               
001A8E  1               
001A8E  1               ; Description: If there is a clock, then print the time
001A8E  1               ;
001A8E  1               ; Input:       Y(hi)/A(lo) 16-bit pointer to 4-byte array
001A8E  1               ;
001A8E  1               ; Output:      Time (hh:mm:ss): hh:mm:ss[.1/100s] to screen
001A8E  1               ;
001A8E  1               ; Clobbered:   A, X, Y
001A8E  1               ;
001A8E  1               ; Globals:     starttime(32-bit), endtime(32-bit)
001A8E  1               
001A8E  1               printtime:
001A8E  1  AE CE 0B     	ldx	gotclock	; check for clock type
001A91  1  D0 01        	bne	:+		;   if zero
001A93  1  60           	rts			;     then return
001A94  1  20 8E FD     :	jsr	crout
001A97  1  A9 A0 A0 1A  	sprint	"Time (hh:mm:ss): "
001A9B  1  20 D4 19 F0  
001A9F  1  12 54 69 6D  
001AA3  1  65 20 28 68  
001AA7  1  68 3A 6D 6D  
001AAB  1  3A 73 73 29  
001AAF  1  3A 20 00     
001AB2  1  38           	sec			; set carry
001AB3  1  AD D7 0B     	lda	endtime+3	; sub starttime 1/100 sec from endtime
001AB6  1  ED D3 0B     	sbc	starttime+3	;   1/100 sec
001AB9  1  B0 05        	bcs	:+		; carry still set?  Positive, no prob
001ABB  1  20 29 1B     	jsr	decsec		; dec a sec
001ABE  1  69 64        	adc	#100		; got neg?  add 100
001AC0  1  8D D3 0B     :	sta	starttime+3	; save it for printing
001AC3  1  38           	sec			; set carry
001AC4  1  AD D4 0B     	lda	endtime+0	; sub starttime sec from endtime sec
001AC7  1  ED D0 0B     	sbc	starttime+0
001ACA  1  B0 05        	bcs	:+		; carry still set?  Positive, no prob
001ACC  1  20 3A 1B     	jsr	decmin		; dec a min
001ACF  1  69 3C        	adc	#60		; got neg?  add 60
001AD1  1  8D D0 0B     :	sta	starttime+0	; save it for printing
001AD4  1  38           	sec			; set carry
001AD5  1  AD D5 0B     	lda	endtime+1	; sub starttime min from endtime min
001AD8  1  ED D1 0B     	sbc	starttime+1
001ADB  1  B0 05        	bcs	:+		; carry still set?  Positive, no prob
001ADD  1  CE D6 0B     	dec	endtime+2	; dec an hour
001AE0  1  69 3C        	adc	#60		; got neg?  add 60
001AE2  1  8D D1 0B     :	sta	starttime+1	; save it for printing
001AE5  1  38           	sec			; set carry
001AE6  1  AD D6 0B     	lda	endtime+2	; sub starttime hr from endtime hr
001AE9  1  ED D2 0B     	sbc	starttime+2
001AEC  1  B0 02        	bcs	:+		; carry still set?  Positive, no prob
001AEE  1  69 18        	adc	#24		; got neg?  add 60
001AF0  1  AA           :	tax			; print hours
001AF1  1  BD 4B 1B     	lda	bintobcd,x
001AF4  1  20 DA FD     	jsr	prbyte
001AF7  1  A9 BA        	lda	#':'+$80
001AF9  1  20 ED FD     	jsr	cout
001AFC  1  AE D1 0B     	ldx	starttime+1	; print minutes
001AFF  1  BD 4B 1B     	lda	bintobcd,x
001B02  1  20 DA FD     	jsr	prbyte
001B05  1  A9 BA        	lda	#':'+$80
001B07  1  20 ED FD     	jsr	cout
001B0A  1  AE D0 0B     	ldx	starttime	; print seconds
001B0D  1  BD 4B 1B     	lda	bintobcd,x
001B10  1  20 DA FD     	jsr	prbyte
001B13  1  AE D3 0B     	ldx	starttime+3
001B16  1  F0 0E        	beq	:+
001B18  1  A9 AE        	lda	#'.'+$80
001B1A  1  20 ED FD     	jsr	cout
001B1D  1  AE D3 0B     	ldx	starttime+3	; print 1/100 seconds
001B20  1  BD 4B 1B     	lda	bintobcd,x
001B23  1  20 DA FD     	jsr	prbyte
001B26  1  4C 8E FD     :	jmp	crout		; crout will have rts
001B29  1               
001B29  1  AE D4 0B     decsec:	ldx	endtime		; load endtime seconds
001B2C  1  D0 08        	bne	:+		; not zero, then just dec it
001B2E  1  20 3A 1B     	jsr	decmin		; got zero, so take a min
001B31  1  A2 3C        	ldx	#60		;   and set sec to 60
001B33  1  8E D4 0B     	stx	endtime
001B36  1  CE D4 0B     :	dec	endtime
001B39  1  60           	rts
001B3A  1               
001B3A  1  AE D5 0B     decmin:	ldx	endtime+1	; load endtime minites
001B3D  1  D0 08        	bne	:+		; not zero, then just dec it
001B3F  1  CE D6 0B     	dec	endtime+2	; got zero, so take an hour
001B42  1  A2 3C        	ldx	#60		;   and set min to 60
001B44  1  8E D5 0B     	stx	endtime+1
001B47  1  CE D5 0B     :	dec	endtime+1
001B4A  1  60           	rts
001B4B  1               
001B4B  1               
001B4B  1               ; Description: BIN/HEX to BCD table.  Used by print_mp and printtime
001B4B  1               
001B4B  1               bintobcd:
001B4B  1  00 01 02 03  	.byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09
001B4F  1  04 05 06 07  
001B53  1  08 09        
001B55  1  10 11 12 13  	.byte	$10,$11,$12,$13,$14,$15,$16,$17,$18,$19
001B59  1  14 15 16 17  
001B5D  1  18 19        
001B5F  1  20 21 22 23  	.byte	$20,$21,$22,$23,$24,$25,$26,$27,$28,$29
001B63  1  24 25 26 27  
001B67  1  28 29        
001B69  1  30 31 32 33  	.byte	$30,$31,$32,$33,$34,$35,$36,$37,$38,$39
001B6D  1  34 35 36 37  
001B71  1  38 39        
001B73  1  40 41 42 43  	.byte	$40,$41,$42,$43,$44,$45,$46,$47,$48,$49
001B77  1  44 45 46 47  
001B7B  1  48 49        
001B7D  1  50 51 52 53  	.byte	$50,$51,$52,$53,$54,$55,$56,$57,$58,$59
001B81  1  54 55 56 57  
001B85  1  58 59        
001B87  1  60 61 62 63  	.byte	$60,$61,$62,$63,$64,$65,$66,$67,$68,$69
001B8B  1  64 65 66 67  
001B8F  1  68 69        
001B91  1  70 71 72 73  	.byte	$70,$71,$72,$73,$74,$75,$76,$77,$78,$79
001B95  1  74 75 76 77  
001B99  1  78 79        
001B9B  1  80 81 82 83  	.byte	$80,$81,$82,$83,$84,$85,$86,$87,$88,$89
001B9F  1  84 85 86 87  
001BA3  1  88 89        
001BA5  1  90 91 92 93  	.byte	$90,$91,$92,$93,$94,$95,$96,$97,$98,$99
001BA9  1  94 95 96 97  
001BAD  1  98 99        
001BAF  1               
001BAF  1               
001BAF  1               ; Description: 16-bit table of 0-255 * 100 broken down into multi100_lo and
001BAF  1               ;              multi100_hi.  Used by print_mp
001BAF  1               
001BAF  1               	.linecont +
001BAF  1               	.define	timestable \
001BAF  1               		00000,00100,00200,00300,00400,00500,00600,00700,\
001BAF  1               		00800,00900,01000,01100,01200,01300,01400,01500,\
001BAF  1               		01600,01700,01800,01900,02000,02100,02200,02300,\
001BAF  1               		02400,02500,02600,02700,02800,02900,03000,03100,\
001BAF  1               		03200,03300,03400,03500,03600,03700,03800,03900,\
001BAF  1               		04000,04100,04200,04300,04400,04500,04600,04700,\
001BAF  1               		04800,04900,05000,05100,05200,05300,05400,05500,\
001BAF  1               		05600,05700,05800,05900,06000,06100,06200,06300,\
001BAF  1               		06400,06500,06600,06700,06800,06900,07000,07100,\
001BAF  1               		07200,07300,07400,07500,07600,07700,07800,07900,\
001BAF  1               		08000,08100,08200,08300,08400,08500,08600,08700,\
001BAF  1               		08800,08900,09000,09100,09200,09300,09400,09500,\
001BAF  1               		09600,09700,09800,09900,10000,10100,10200,10300,\
001BAF  1               		10400,10500,10600,10700,10800,10900,11000,11100,\
001BAF  1               		11200,11300,11400,11500,11600,11700,11800,11900,\
001BAF  1               		12000,12100,12200,12300,12400,12500,12600,12700,\
001BAF  1               		12800,12900,13000,13100,13200,13300,13400,13500,\
001BAF  1               		13600,13700,13800,13900,14000,14100,14200,14300,\
001BAF  1               		14400,14500,14600,14700,14800,14900,15000,15100,\
001BAF  1               		15200,15300,15400,15500,15600,15700,15800,15900,\
001BAF  1               		16000,16100,16200,16300,16400,16500,16600,16700,\
001BAF  1               		16800,16900,17000,17100,17200,17300,17400,17500,\
001BAF  1               		17600,17700,17800,17900,18000,18100,18200,18300,\
001BAF  1               		18400,18500,18600,18700,18800,18900,19000,19100,\
001BAF  1               		19200,19300,19400,19500,19600,19700,19800,19900,\
001BAF  1               		20000,20100,20200,20300,20400,20500,20600,20700,\
001BAF  1               		20800,20900,21000,21100,21200,21300,21400,21500,\
001BAF  1               		21600,21700,21800,21900,22000,22100,22200,22300,\
001BAF  1               		22400,22500,22600,22700,22800,22900,23000,23100,\
001BAF  1               		23200,23300,23400,23500,23600,23700,23800,23900,\
001BAF  1               		24000,24100,24200,24300,24400,24500,24600,24700,\
001BAF  1               		24800,24900,25000,25100,25200,25300,25400,25500
001BAF  1               
001BAF  1  xx xx xx xx  	.align	256		; speed bump (~.35 sec for 1000 digits)
001BB3  1  xx xx xx xx  
001BB7  1  xx xx xx xx  
001BBB  1  xx xx xx xx  
001BBF  1  xx xx xx xx  
001BC3  1  xx xx xx xx  
001BC7  1  xx xx xx xx  
001BCB  1  xx xx xx xx  
001BCF  1  xx xx xx xx  
001BD3  1  xx xx xx xx  
001BD7  1  xx xx xx xx  
001BDB  1  xx xx xx xx  
001BDF  1  xx xx xx xx  
001BE3  1  xx xx xx xx  
001BE7  1  xx xx xx xx  
001BEB  1  xx xx xx xx  
001BEF  1  xx xx xx xx  
001BF3  1  xx xx xx xx  
001BF7  1  xx xx xx xx  
001BFB  1  xx xx xx xx  
001BFF  1  xx           
001C00  1               				; read_noslotclock has to be aligned anyway
001C00  1               				; so extra bytes in obj code already there
001C00  1               mult100_lo:
001C00  1  00 64 C8 2C  	.lobytes timestable
001C04  1  90 F4 58 BC  
001C08  1  20 84 E8 4C  
001C0C  1  B0 14 78 DC  
001C10  1  40 A4 08 6C  
001C14  1  D0 34 98 FC  
001C18  1  60 C4 28 8C  
001C1C  1  F0 54 B8 1C  
001C20  1  80 E4 48 AC  
001C24  1  10 74 D8 3C  
001C28  1  A0 04 68 CC  
001C2C  1  30 94 F8 5C  
001C30  1  C0 24 88 EC  
001C34  1  50 B4 18 7C  
001C38  1  E0 44 A8 0C  
001C3C  1  70 D4 38 9C  
001C40  1  00 64 C8 2C  
001C44  1  90 F4 58 BC  
001C48  1  20 84 E8 4C  
001C4C  1  B0 14 78 DC  
001C50  1  40 A4 08 6C  
001C54  1  D0 34 98 FC  
001C58  1  60 C4 28 8C  
001C5C  1  F0 54 B8 1C  
001C60  1  80 E4 48 AC  
001D00  1               mult100_hi:
001D00  1  00 00 00 01  	.hibytes timestable
001D04  1  01 01 02 02  
001D08  1  03 03 03 04  
001D0C  1  04 05 05 05  
001D10  1  06 06 07 07  
001D14  1  07 08 08 08  
001D18  1  09 09 0A 0A  
001D1C  1  0A 0B 0B 0C  
001D20  1  0C 0C 0D 0D  
001D24  1  0E 0E 0E 0F  
001D28  1  0F 10 10 10  
001D2C  1  11 11 11 12  
001D30  1  12 13 13 13  
001D34  1  14 14 15 15  
001D38  1  15 16 16 17  
001D3C  1  17 17 18 18  
001D40  1  19 19 19 1A  
001D44  1  1A 1A 1B 1B  
001D48  1  1C 1C 1C 1D  
001D4C  1  1D 1E 1E 1E  
001D50  1  1F 1F 20 20  
001D54  1  20 21 21 21  
001D58  1  22 22 23 23  
001D5C  1  23 24 24 25  
001D60  1  25 25 26 26  
001E00  1               
001E00  1               
001E00  1               ; Description: Cleaned up disassembly of the No Slot Clock DOS clockread
001E00  1               ;              utility.  This code MUST be page aligned.
001E00  1               ;
001E00  1               ; Output:      nsc_* updated
001E00  1               ;
001E00  1               ; Clobbered:   A, X, Y
001E00  1               ;
001E00  1               ; Locals:
001E00  1               
001E00  1               dosptr	=	$43
001E00  1               	.align	256		; must be aligned to page
001E00  1               read_noslotclock:
001E00  1  38           	sec
001E01  1  B0 10        	bcs     :+
001E03  1  57           nsc_yr:	.byte	$57		; binary year
001E04  1  04           nsc_mo:	.byte	$04		; binary month
001E05  1  08           nsc_dt:	.byte	$08		; binary day of month
001E06  1  04           nsc_dy:	.byte	$04		; binary day of week
001E07  1  0E           nsc_h:	.byte	$0E		; binary hour
001E08  1  2C           nsc_m:	.byte	$2C		; binary minute
001E09  1  00           nsc_s:	.byte	$00		; binary second
001E0A  1  00           nsc_ss:	.byte	$00		; binary 1/100th of second
001E0B  1  5C A3 3A C5  	.byte	$5C,$A3,$3A,$C5,$5C,$A3,$3A,$C5
001E0F  1  5C A3 3A C5  
001E13  1  78           :	sei
001E14  1  AD FF CF     	lda     $CFFF
001E17  1  48           	pha
001E18  1  8D 00 C3     	sta     $C300
001E1B  1  AD 04 C8     	lda     $C804
001E1E  1  A2 0A        	ldx     #$0A
001E20  1  B5 41        :	lda     $41,x
001E22  1  48           	pha
001E23  1  CA           	dex
001E24  1  D0 FA        	bne     :-
001E26  1  A9 0B        	lda     #$0B
001E28  1  85 42        	sta     $42
001E2A  1  A9 60        	lda     #$60
001E2C  1  85 43        	sta     dosptr
001E2E  1  20 43 00     	jsr     dosptr
001E31  1  BA           	tsx
001E32  1  BD 00 01     	lda     $0100,x
001E35  1  85 43        	sta     dosptr
001E37  1  A0 07        	ldy     #$07
001E39  1  B1 42        :	lda     ($42),y
001E3B  1  38           	sec
001E3C  1  6A           	ror     a
001E3D  1  48           :	pha
001E3E  1  A9 00        	lda     #$00
001E40  1  2A           	rol     a
001E41  1  AA           	tax
001E42  1  BD 00 C8     	lda     $C800,x
001E45  1  68           	pla
001E46  1  4A           	lsr     a
001E47  1  D0 F4        	bne     :-
001E49  1  88           	dey
001E4A  1  10 ED        	bpl     :--
001E4C  1  A2 07        	ldx     #$07
001E4E  1  A0 07        :	ldy     #$07
001E50  1  AD 04 C8     :	lda     $C804
001E53  1  6A           	ror     a
001E54  1  76 44        	ror     $44,x
001E56  1  88           	dey
001E57  1  10 F7        	bpl     :-
001E59  1  B5 44        	lda     $44,x
001E5B  1  48           	pha
001E5C  1  29 0F        	and     #$0F
001E5E  1  95 44        	sta     $44,x
001E60  1  68           	pla
001E61  1  29 F0        	and     #$F0
001E63  1  4A           	lsr     a
001E64  1  4A           	lsr     a
001E65  1  4A           	lsr     a
001E66  1  4A           	lsr     a
001E67  1  A8           	tay
001E68  1  F0 07        	beq     :++
001E6A  1  A9 00        	lda     #$00
001E6C  1  69 0A        :	adc     #$0A
001E6E  1  88           	dey
001E6F  1  D0 FB        	bne     :-
001E71  1  75 44        :	adc     $44,x
001E73  1  95 44        	sta     $44,x
001E75  1  CA           	dex
001E76  1  10 D6        	bpl     :----
001E78  1  A9 03        	lda     #$03
001E7A  1  85 42        	sta     $42
001E7C  1  A0 07        	ldy     #$07
001E7E  1  B9 44 00     :	lda     $44,y
001E81  1  91 42        	sta     ($42),y
001E83  1  88           	dey
001E84  1  10 F8        	bpl     :-
001E86  1  A2 00        	ldx     #$00
001E88  1  68           :	pla
001E89  1  95 42        	sta     $42,x
001E8B  1  E8           	inx
001E8C  1  8A           	txa
001E8D  1  C9 0A        	cmp     #$0A
001E8F  1  D0 F7        	bne     :-
001E91  1  68           	pla
001E92  1  2A           	rol     a
001E93  1  B0 03        	bcs     :+
001E95  1  8D FF CF     	sta     $CFFF
001E98  1  60           :	rts
001E99  1               
001E99  1               
001E99  1               ;; end of subs start of heap
001E99  1               
001E99  1               end:
001E99  1               heap:				; start of dynamic memory
001E99  1               
